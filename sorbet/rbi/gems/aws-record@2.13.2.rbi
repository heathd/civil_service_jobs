# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `aws-record` gem.
# Please instead update this file by running `bin/tapioca gem aws-record`.


# source://aws-record//lib/aws-record/record/client_configuration.rb#3
module Aws
  class << self
    # source://aws-sdk-core/3.201.5/lib/aws-sdk-core.rb#138
    def config; end

    # source://aws-sdk-core/3.201.5/lib/aws-sdk-core.rb#141
    def config=(config); end

    # source://aws-sdk-core/3.201.5/lib/aws-sdk-core.rb#200
    def eager_autoload!(*args); end

    # source://aws-sdk-core/3.201.5/lib/aws-sdk-core.rb#193
    def empty_connection_pools!; end

    # source://aws-sdk-core/3.201.5/lib/aws-sdk-core.rb#150
    def partition(partition_name); end

    # source://aws-sdk-core/3.201.5/lib/aws-sdk-core.rb#155
    def partitions; end

    # source://aws-sdk-core/3.201.5/lib/aws-sdk-core.rb#131
    def shared_config; end

    # source://aws-sdk-core/3.201.5/lib/aws-sdk-core.rb#170
    def use_bundled_cert!; end
  end
end

# +Aws::Record+ is the module you include in your model classes in order to
# decorate them with the Amazon DynamoDB integration methods provided by this
# library. Methods you can use are shown below, in sub-modules organized by
# functionality.
# === Inheritance Support
# Aws Record models can be extended using standard ruby inheritance. The child
# model must include +Aws::Record+ in their model and the following will
# be inherited:
# * {#set_table_name set_table_name}
# * {#initialize Attributes and keys}
# * Mutation Tracking:
#   * {#enable_mutation_tracking enable_mutation_tracking}
#   * {#disable_mutation_tracking disable_mutation_tracking}
# * {#local_secondary_indexes local_secondary_indexes}
# * {#global_secondary_indexes global_secondary_indexes}
# * {ClientConfiguration#configure_client configure_client}
# See example below to see the feature in action.
#
# @example A class definition using +Aws::Record+
#   class MyModel
#   include Aws::Record
#   string_attr     :uuid,    hash_key: true
#   integer_attr    :post_id, range_key: true
#   boolean_attr    :is_active
#   datetime_attr   :created_at
#   string_set_attr :tags
#   map_attr        :metadata
#   end
# @example Inheritance between models
#   class Animal
#   include Aws::Record
#   string_attr :name, hash_key: true
#   integer_attr :age
#   end
#
#   class Dog < Animal
#   include Aws::Record
#   boolean_attr :family_friendly
#   end
#
#   dog = Dog.find(name: 'Sunflower')
#   dog.age = 3
#   dog.family_friendly = true
#
# source://aws-record//lib/aws-record/record/client_configuration.rb#4
module Aws::Record
  include ::Aws::Record::Attributes
  include ::Aws::Record::ItemOperations
  include ::Aws::Record::DirtyTracking
  include ::Aws::Record::Query
  include ::Aws::Record::SecondaryIndexes

  mixes_in_class_methods ::Aws::Record::ClientConfiguration
  mixes_in_class_methods ::Aws::Record::RecordClassMethods
  mixes_in_class_methods ::Aws::Record::Attributes::ClassMethods
  mixes_in_class_methods ::Aws::Record::ItemOperations::ItemOperationsClassMethods
  mixes_in_class_methods ::Aws::Record::DirtyTracking::DirtyTrackingClassMethods
  mixes_in_class_methods ::Aws::Record::Query::QueryClassMethods
  mixes_in_class_methods ::Aws::Record::SecondaryIndexes::SecondaryIndexesClassMethods

  private

  # source://aws-record//lib/aws-record/record.rb#93
  def dynamodb_client; end

  class << self
    # @api private
    # @return [Boolean]
    #
    # source://aws-record//lib/aws-record/record.rb#79
    def extends_record?(klass); end

    # Usage of {Aws::Record} requires only that you include this module. This
    # method will then pull in the other default modules.
    #
    # @example
    #   class MyTable
    #   include Aws::Record
    #   # Attribute definitions go here...
    #   end
    #
    # source://aws-record//lib/aws-record/record.rb#67
    def included(sub_class); end

    private

    # @api private
    #
    # source://aws-record//lib/aws-record/record.rb#84
    def inherit_track_mutations(klass); end
  end
end

# This class provides helper methods for +Aws::Record+ attributes. These
# include marshalers for type casting of item attributes, the Amazon
# DynamoDB type for use in certain table and item operation calls, and the
# ability to define a database name that is separate from the name used
# within the model class and item instances.
#
# source://aws-record//lib/aws-record/record/attribute.rb#10
class Aws::Record::Attribute
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param name [Symbol] Name of the attribute. It should be a name that is
  #   safe to use as a method.
  # @param options [Hash]
  # @return [Attribute] a new instance of Attribute
  #
  # source://aws-record//lib/aws-record/record/attribute.rb#37
  def initialize(name, options = T.unsafe(nil)); end

  # Returns the value of attribute database_name.
  #
  # source://aws-record//lib/aws-record/record/attribute.rb#11
  def database_name; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/attribute.rb#84
  def default_value; end

  # Returns the value of attribute dynamodb_type.
  #
  # source://aws-record//lib/aws-record/record/attribute.rb#11
  def dynamodb_type; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/attribute.rb#79
  def extract(dynamodb_item); end

  # Returns the value of attribute name.
  #
  # source://aws-record//lib/aws-record/record/attribute.rb#11
  def name; end

  # @return [Boolean] +true+ if this attribute will actively persist nil
  #   values, +false+ otherwise. Default: +false+
  #
  # source://aws-record//lib/aws-record/record/attribute.rb#74
  def persist_nil?; end

  # Attempts to serialize a raw value into the attribute's serialized
  # storage type. This call will forward the raw value to this attribute's
  # marshaler class.
  #
  # @return [Object] the serialized object. Return type is dependent on the
  #   marshaler used. See your attribute's marshaler class for details.
  #
  # source://aws-record//lib/aws-record/record/attribute.rb#66
  def serialize(raw_value); end

  # Attempts to type cast a raw value into the attribute's type. This call
  # will forward the raw value to this attribute's marshaler class.
  #
  # @return [Object] the type cast object. Return type is dependent on the
  #   marshaler used. See your attribute's marshaler class for details.
  #
  # source://aws-record//lib/aws-record/record/attribute.rb#54
  def type_cast(raw_value); end

  private

  # source://aws-record//lib/aws-record/record/attribute.rb#94
  def _deep_copy(obj); end

  # @return [Boolean]
  #
  # source://aws-record//lib/aws-record/record/attribute.rb#98
  def _is_lambda?(obj); end
end

# source://aws-record//lib/aws-record/record/attributes.rb#5
module Aws::Record::Attributes
  mixes_in_class_methods ::Aws::Record::Attributes::ClassMethods

  # Base initialization method for a new item. Optionally, allows you to
  # provide initial attribute values for the model. You do not need to
  # provide all, or even any, attributes at item creation time.
  #
  # === Inheritance Support
  # Child models will inherit the attributes and keys defined in the parent
  # model. Child models can override attribute keys if defined in their own model.
  #
  # See examples below to see the feature in action.
  #
  # @example Usage Example
  #   class MyModel
  #   include Aws::Record
  #   integer_attr :id,   hash_key: true
  #   string_attr  :name, range_key: true
  #   string_attr  :body
  #   end
  #
  #   item = MyModel.new(id: 1, name: "Quick Create")
  # @example Child model inheriting from Parent model
  #   class Animal
  #   include Aws::Record
  #   string_attr :name,   hash_key: true
  #   integer_attr :age,   default_value: 1
  #   end
  #
  #   class Cat < Animal
  #   include Aws::Record
  #   integer_attr :num_of_wiskers
  #   end
  #
  #   cat = Cat.find(name: 'Foo')
  #   cat.age    # => 1
  #   cat.num_of_wiskers = 200
  # @example Child model overrides the hash key
  #   class Animal
  #   include Aws::Record
  #   string_attr :name,   hash_key: true
  #   integer_attr :age,   range_key: true
  #   end
  #
  #   class Dog < Animal
  #   include Aws::Record
  #   integer_attr :id, hash_key: true
  #   end
  #
  #   Dog.keys # => {:hash=>:id, :range=>:age}
  # @param attr_values [Hash] Attribute symbol/value pairs for any initial
  #   attribute values you wish to set.
  # @return [Aws::Record] An item instance for your model.
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#63
  def initialize(attr_values = T.unsafe(nil)); end

  # Returns a hash representation of the attribute data.
  #
  # @return [Hash] Map of attribute names to raw values.
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#76
  def to_h; end

  class << self
    # @private
    #
    # source://aws-record//lib/aws-record/record/attributes.rb#6
    def included(sub_class); end

    private

    # source://aws-record//lib/aws-record/record/attributes.rb#80
    def inherit_attributes(klass); end
  end
end

# source://aws-record//lib/aws-record/record/attributes.rb#97
module Aws::Record::Attributes::ClassMethods
  # Define an atomic counter attribute for your model.
  #
  # Atomic counter are an integer-type attribute that is incremented,
  # unconditionally, without interfering with other write requests.
  # The numeric value increments each time you call +increment_<attr>!+.
  # If a specific numeric value are passed in the call, the attribute will
  # increment by that value.
  #
  # To use +increment_<attr>!+ method, the following condition must be true:
  # * None of the attributes have dirty changes.
  # * If there is a value passed in, it must be an integer.
  # For more information, see
  # {https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html#WorkingWithItems.AtomicCounters
  # Atomic counter} in the Amazon DynamoDB Developer Guide.
  #
  # @example Usage Example
  #   class MyRecord
  #   include Aws::Record
  #   integer_attr :id, hash_key: true
  #   atomic_counter :counter
  #   end
  #
  #   record = MyRecord.find(id: 1)
  #   record.counter #=> 0
  #   record.increment_counter! #=> 1
  #   record.increment_counter!(2) #=> 3
  # @option opts
  # @param name [Symbol] Name of this attribute.  It should be a name that
  #   is safe to use as a method.
  # @param opts [Hash]
  # @see #attr #attr method for additional hash options.
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#470
  def atomic_counter(name, opts = T.unsafe(nil)); end

  # Define an attribute for your model, providing your own attribute type.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol] Name of this attribute.  It should be a name that
  #   is safe to use as a method.
  # @param marshaler [Marshaler] The marshaler for this attribute. So long
  #   as you provide a marshaler which implements +#type_cast+ and
  #   +#serialize+ that consume raw values as expected, you can bring your
  #   own marshaler type. Convenience methods will provide this for you.
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#128
  def attr(name, marshaler, opts = T.unsafe(nil)); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#515
  def attributes; end

  # Define a boolean-type attribute for your model.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol] Name of this attribute.  It should be a name that
  #   is safe to use as a method.
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#173
  def boolean_attr(name, opts = T.unsafe(nil)); end

  # Define a date-type attribute for your model.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option options
  # @param name [Symbol] Name of this attribute.  It should be a name that
  #   is safe to use as a method.
  # @param opts [Hash]
  # @param options [Hash] a customizable set of options
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#239
  def date_attr(name, opts = T.unsafe(nil)); end

  # Define a datetime-type attribute for your model.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol] Name of this attribute.  It should be a name that
  #   is safe to use as a method.
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#261
  def datetime_attr(name, opts = T.unsafe(nil)); end

  # Define a time-type attribute for your model which persists as
  # epoch-seconds.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol] Name of this attribute.  It should be a name
  #   that is safe to use as a method.
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#306
  def epoch_time_attr(name, opts = T.unsafe(nil)); end

  # Define a float-type attribute for your model.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol] Name of this attribute.  It should be a name that
  #   is safe to use as a method.
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#217
  def float_attr(name, opts = T.unsafe(nil)); end

  # @return [Symbol, nil] The symbolic name of the table's hash key.
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#505
  def hash_key; end

  # Define a integer-type attribute for your model.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol] Name of this attribute.  It should be a name that
  #   is safe to use as a method.
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#195
  def integer_attr(name, opts = T.unsafe(nil)); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#520
  def keys; end

  # Define a list-type attribute for your model.
  #
  # Lists do not have to be homogeneous, but they do have to be types that
  # the AWS SDK for Ruby V3's DynamoDB client knows how to marshal and
  # unmarshal. Those types are:
  #
  # * Hash
  # * Array
  # * String
  # * Numeric
  # * Boolean
  # * IO
  # * Set
  # * nil
  #
  # Also note that, since lists are heterogeneous, you may lose some
  # precision when marshaling and unmarshaling. For example, symbols will
  # be stringified, but there is no way to return those strings to symbols
  # when the object is read back from DynamoDB.
  #
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol] Name of this attribute.  It should be a name that
  #   is safe to use as a method.
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#342
  def list_attr(name, opts = T.unsafe(nil)); end

  # Define a map-type attribute for your model.
  #
  # Maps do not have to be homogeneous, but they do have to use types that
  # the AWS SDK for Ruby V3's DynamoDB client knows how to marshal and
  # unmarshal. Those types are:
  #
  # * Hash
  # * Array
  # * String
  # * Numeric
  # * Boolean
  # * IO
  # * Set
  # * nil
  #
  # Also note that, since maps are heterogeneous, you may lose some
  # precision when marshaling and unmarshaling. For example, symbols will
  # be stringified, but there is no way to return those strings to symbols
  # when the object is read back from DynamoDB.
  #
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol] Name of this attribute.  It should be a name that
  #   is safe to use as a method.
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#378
  def map_attr(name, opts = T.unsafe(nil)); end

  # Define a numeric set attribute for your model.
  #
  # Numeric sets are homogeneous sets, containing only numbers. Note that
  # empty sets cannot be persisted to DynamoDB. Empty sets are valid for
  # aws-record items, but they will not be persisted as sets. nil values
  # from your table, or a lack of value from your table, will be treated
  # as an empty set for item instances. At persistence time, the marshaler
  # will attempt to marshal any non-numerics within the set to be Numeric
  # objects.
  #
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol] Name of this attribute.  It should be a name that
  #   is safe to use as a method.
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#430
  def numeric_set_attr(name, opts = T.unsafe(nil)); end

  # @return [Symbol, nil] The symbolic name of the table's range key, or nil if there is no range key.
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#510
  def range_key; end

  # Define a string-type attribute for your model.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol] Name of this attribute.  It should be a name that
  #   is safe to use as a method.
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#151
  def string_attr(name, opts = T.unsafe(nil)); end

  # Define a string set attribute for your model.
  #
  # String sets are homogeneous sets, containing only strings. Note that
  # empty sets cannot be persisted to DynamoDB. Empty sets are valid for
  # aws-record items, but they will not be persisted as sets. nil values
  # from your table, or a lack of value from your table, will be treated
  # as an empty set for item instances. At persistence time, the marshaler
  # will attempt to marshal any non-strings within the set to be String
  # objects.
  #
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol] Name of this attribute.  It should be a name that
  #   is safe to use as a method.
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#404
  def string_set_attr(name, opts = T.unsafe(nil)); end

  # Define a time-type attribute for your model.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol] Name of this attribute.  It should be a name that
  #   is safe to use as a method.
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/attributes.rb#283
  def time_attr(name, opts = T.unsafe(nil)); end

  private

  # source://aws-record//lib/aws-record/record/attributes.rb#526
  def _define_attr_methods(name); end

  # source://aws-record//lib/aws-record/record/attributes.rb#536
  def _key_attributes(id, opts); end
end

# source://aws-record//lib/aws-record/record/batch.rb#5
class Aws::Record::Batch
  extend ::Aws::Record::ClientConfiguration

  class << self
    # Provides support for the
    # {https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#batch_get_item-instance_method
    # Aws::DynamoDB::Client#batch_get_item} for aws-record models.
    #
    # +Aws::Record::Batch+ is Enumerable and using Enumerable methods will handle
    # paging through all requested keys automatically. Alternatively, a lower level
    # interface is available. You can determine if there are any unprocessed keys by calling
    # {BatchRead.complete? .complete?} and any unprocessed keys can be processed by
    # calling {BatchRead.execute! .execute!}. You can access all processed items
    # through {BatchRead.items .items}.
    #
    # The +batch_get_item+ supports up to 100 operations in a single call and a single
    # operation can retrieve up to 16 MB of data.
    #
    # +Aws::Record::BatchRead+ can take more than 100 item keys. The first 100 requests
    # will be processed and the remaining requests will be stored.
    # When using Enumerable methods, any pending item keys will be automatically
    # processed and the new items will be added to +items+.
    # Alternately, use {BatchRead.execute! .execute!} to process any pending item keys.
    #
    # All processed operations can be accessed by {BatchRead.items items} - which is an
    # array of modeled items from the response. The items will be unordered since
    # DynamoDB does not return items in any particular order.
    #
    # If a requested item does not exist in the database, it is not returned in the response.
    #
    # If there is a returned item from the call and there's no reference model class
    # to be found, the item will not show up under +items+.
    #
    # @example Usage Example
    #   class Lunch
    #   include Aws::Record
    #   integer_attr :id,   hash_key: true
    #   string_attr  :name, range_key: true
    #   end
    #
    #   class Dessert
    #   include Aws::Record
    #   integer_attr :id,   hash_key: true
    #   string_attr  :name, range_key: true
    #   end
    #
    #   # batch operations
    #   operation = Aws::Record::Batch.read do |db|
    #   db.find(Lunch, id: 1, name: 'Papaya Salad')
    #   db.find(Lunch, id: 2, name: 'BLT Sandwich')
    #   db.find(Dessert, id: 1, name: 'Apple Pie')
    #   end
    #
    #   # BatchRead is enumerable and handles pagination
    #   operation.each { |item| item.id }
    #
    #   # Alternatively, BatchRead provides a lower level
    #   # interface through: execute!, complete? and items.
    #   # Unprocessed items can be processed by calling:
    #   operation.execute! until operation.complete?
    # @option opts
    # @param opts [Hash] the options you wish to use to create the client.
    #   Note that if you include the option +:client+, all other options
    #   will be ignored. See the documentation for other options in the
    #   {https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#initialize-instance_method
    #   AWS SDK for Ruby}.
    # @return [Aws::Record::BatchRead] An instance that contains modeled items
    #   from the +BatchGetItem+ result and stores unprocessed keys to be
    #   manually processed later.
    # @yield [batch]
    #
    # source://aws-record//lib/aws-record/record/batch.rb#138
    def read(opts = T.unsafe(nil)); end

    # Provides a thin wrapper to the
    # {https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#batch_write_item-instance_method
    # Aws::DynamoDB::Client#batch_write_item} method. Up to 25 +PutItem+ or +DeleteItem+
    # operations are supported. A single request may write up to 16 MB of data, with each
    # item having a write limit of 400 KB.
    #
    # *Note*: this operation does not support dirty attribute handling,
    # nor does it enforce safe write operations (i.e. update vs new record
    # checks).
    #
    # This call may partially execute write operations. Failed operations
    # are returned as {BatchWrite.unprocessed_items unprocessed_items} (i.e. the
    # table fails to meet requested write capacity). Any unprocessed
    # items may be retried by calling {BatchWrite.execute! .execute!}
    # again. You can determine if the request needs to be retried by calling
    # the {BatchWrite.complete? .complete?} method - which returns +true+
    # when all operations have been completed.
    #
    # Please see
    # {https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.BatchOperations
    # Batch Operations and Error Handling} in the DynamoDB Developer Guide for
    # more details.
    #
    # @example Usage Example
    #   class Breakfast
    #   include Aws::Record
    #   integer_attr :id,   hash_key: true
    #   string_attr  :name, range_key: true
    #   string_attr  :body
    #   end
    #
    #   # setup
    #   eggs = Breakfast.new(id: 1, name: "eggs").save!
    #   waffles = Breakfast.new(id: 2, name: "waffles")
    #   pancakes = Breakfast.new(id: 3, name: "pancakes")
    #
    #   # batch operations
    #   operation = Aws::Record::Batch.write(client: Breakfast.dynamodb_client) do |db|
    #   db.put(waffles)
    #   db.delete(eggs)
    #   db.put(pancakes)
    #   end
    #
    #   # unprocessed items can be retried by calling Aws::Record::BatchWrite#execute!
    #   operation.execute! until operation.complete?
    # @option opts
    # @param opts [Hash] the options you wish to use to create the client.
    #   Note that if you include the option +:client+, all other options
    #   will be ignored. See the documentation for other options in the
    #   {https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#initialize-instance_method
    #   AWS SDK for Ruby}.
    # @return [Aws::Record::BatchWrite] An instance that contains any
    #   unprocessed items and allows for a retry strategy.
    # @yield [batch]
    #
    # source://aws-record//lib/aws-record/record/batch.rb#65
    def write(opts = T.unsafe(nil)); end
  end
end

# source://aws-record//lib/aws-record/record/batch_read.rb#5
class Aws::Record::BatchRead
  include ::Enumerable

  # @option opts
  # @param opts [Hash]
  # @return [BatchRead] a new instance of BatchRead
  #
  # source://aws-record//lib/aws-record/record/batch_read.rb#13
  def initialize(opts = T.unsafe(nil)); end

  # Indicates if all item keys have been processed.
  #
  # See {Batch.read} for example usage.
  #
  # @return [Boolean] +true+ if all item keys has been processed, +false+ otherwise.
  #
  # source://aws-record//lib/aws-record/record/batch_read.rb#78
  def complete?; end

  # Provides an enumeration of the results from the +batch_get_item+ request
  # and handles pagination.
  #
  # Any pending item keys will be automatically processed and be
  # added to the {#items}.
  #
  # See {Batch.read} for example usage.
  #
  # @return [Enumerable<BatchRead>] an enumeration over the results of
  #   +batch_get_item+ request.
  # @yieldparam item [Aws::Record] a modeled item
  #
  # source://aws-record//lib/aws-record/record/batch_read.rb#63
  def each(&block); end

  # Perform a +batch_get_item+ request.
  #
  # This method processes the first 100 item keys and
  # returns an array of new modeled items.
  #
  # See {Batch.read} for example usage.
  #
  # @return [Array] an array of unordered new items
  #
  # source://aws-record//lib/aws-record/record/batch_read.rb#39
  def execute!; end

  # Append the item keys to a batch read request.
  #
  # See {Batch.read} for example usage.
  #
  # @param klass [Aws::Record] a model class that includes {Aws::Record}
  # @param key [Hash] attribute-value pairs for the key you wish to search for.
  # @raise [Aws::Record::Errors::KeyMissing] if your option parameters
  #   do not include all item keys defined in the model.
  # @raise [ArgumentError] if the provided item keys is a duplicate request
  #   in the same instance.
  #
  # source://aws-record//lib/aws-record/record/batch_read.rb#26
  def find(klass, key = T.unsafe(nil)); end

  # Returns an array of modeled items. The items are marshaled into classes used in {#find} method.
  # These items will be unordered since DynamoDB does not return items in any particular order.
  #
  # See {Batch.read} for example usage.
  #
  # @return [Array] an array of modeled items from the +batch_get_item+ call.
  #
  # source://aws-record//lib/aws-record/record/batch_read.rb#87
  def items; end

  private

  # source://aws-record//lib/aws-record/record/batch_read.rb#172
  def build_item(item, item_class); end

  # source://aws-record//lib/aws-record/record/batch_read.rb#137
  def build_items(item_responses); end

  # source://aws-record//lib/aws-record/record/batch_read.rb#129
  def build_operations(keys); end

  # @return [Boolean]
  #
  # source://aws-record//lib/aws-record/record/batch_read.rb#168
  def contains_keys?(item, keys); end

  # source://aws-record//lib/aws-record/record/batch_read.rb#163
  def find_item_class(table, item); end

  # source://aws-record//lib/aws-record/record/batch_read.rb#101
  def format_unprocessed_key(klass, key); end

  # source://aws-record//lib/aws-record/record/batch_read.rb#97
  def item_classes; end

  # source://aws-record//lib/aws-record/record/batch_read.rb#118
  def store_item_class(klass, key); end

  # source://aws-record//lib/aws-record/record/batch_read.rb#114
  def store_unprocessed_key(klass, unprocessed_key); end

  # source://aws-record//lib/aws-record/record/batch_read.rb#93
  def unprocessed_keys; end

  # source://aws-record//lib/aws-record/record/batch_read.rb#155
  def update_unprocessed_keys(keys); end
end

# @api private
#
# source://aws-record//lib/aws-record/record/batch_read.rb#9
Aws::Record::BatchRead::BATCH_GET_ITEM_LIMIT = T.let(T.unsafe(nil), Integer)

# source://aws-record//lib/aws-record/record/batch_write.rb#5
class Aws::Record::BatchWrite
  # @option opts
  # @param opts [Hash]
  # @return [BatchWrite] a new instance of BatchWrite
  #
  # source://aws-record//lib/aws-record/record/batch_write.rb#8
  def initialize(opts = T.unsafe(nil)); end

  # Indicates if all items have been processed.
  #
  # See {Batch.write} for example usage.
  #
  # @return [Boolean] +true+ if +unprocessed_items+ is empty, +false+
  #   otherwise
  #
  # source://aws-record//lib/aws-record/record/batch_write.rb#49
  def complete?; end

  # Append a +DeleteItem+ operation to a batch write request.
  #
  # See {Batch.write} for example usage.
  #
  # @param record [Aws::Record] a model class that includes {Aws::Record}.
  #
  # source://aws-record//lib/aws-record/record/batch_write.rb#27
  def delete(record); end

  # Perform a +batch_write_item+ request.
  #
  # See {Batch.write} for example usage.
  #
  # @return [Aws::Record::BatchWrite] an instance that provides access to
  #   unprocessed items and allows for retries.
  #
  # source://aws-record//lib/aws-record/record/batch_write.rb#38
  def execute!; end

  # Append a +PutItem+ operation to a batch write request.
  #
  # See {Batch.write} for example usage.
  #
  # @param record [Aws::Record] a model class that includes {Aws::Record}.
  #
  # source://aws-record//lib/aws-record/record/batch_write.rb#17
  def put(record); end

  # Returns all +DeleteItem+ and +PutItem+ operations that have not yet been
  # processed successfully.
  #
  # See {Batch.write} for example usage.
  #
  # @return [Hash] All operations that have not yet successfully completed.
  #
  # source://aws-record//lib/aws-record/record/batch_write.rb#58
  def unprocessed_items; end

  private

  # source://aws-record//lib/aws-record/record/batch_write.rb#64
  def operations; end

  # source://aws-record//lib/aws-record/record/batch_write.rb#68
  def record_delete_params(record); end

  # source://aws-record//lib/aws-record/record/batch_write.rb#72
  def record_put_params(record); end
end

# source://aws-record//lib/aws-record/record/buildable_search.rb#5
class Aws::Record::BuildableSearch
  # This should never be called directly, rather it is called by the
  # #build_query or #build_scan methods of your aws-record model class.
  #
  # @raise [ArgumentError]
  # @return [BuildableSearch] a new instance of BuildableSearch
  #
  # source://aws-record//lib/aws-record/record/buildable_search.rb#10
  def initialize(opts); end

  # You must call this method at the end of any query or scan you build.
  #
  # @return [Aws::Record::ItemCollection] The item collection lazy
  #   enumerable.
  #
  # source://aws-record//lib/aws-record/record/buildable_search.rb#227
  def complete!; end

  # If true, will perform your query or scan as a consistent read. If false,
  # the query or scan is eventually consistent.
  #
  # source://aws-record//lib/aws-record/record/buildable_search.rb#33
  def consistent_read(b); end

  # If you have an exclusive start key for your query or scan, you can
  # provide it with this builder method. You should not use this if you are
  # querying or scanning without a set starting point, as the
  # {Aws::Record::ItemCollection} class handles pagination automatically
  # for you.
  #
  # source://aws-record//lib/aws-record/record/buildable_search.rb#68
  def exclusive_start_key(key); end

  # Provide a filter expression for your query or scan using a substitution
  # expression.
  #
  # @example Building a simple scan:
  #   # Example model class
  #   class ExampleTable
  #   include Aws::Record
  #   string_attr  :uuid, hash_key: true
  #   integer_attr :id,   range_key: true
  #   string_attr  :body
  #   end
  #
  #   scan = ExampleTable.build_scan.filter_expr(
  #   "contains(:body, ?)",
  #   "bacon"
  #   ).complete!
  #
  # source://aws-record//lib/aws-record/record/buildable_search.rb#125
  def filter_expr(statement_str, *subs); end

  # Provide a key condition expression for your query using a substitution
  # expression.
  #
  # @example Building a simple query with a key expression:
  #   # Example model class
  #   class ExampleTable
  #   include Aws::Record
  #   string_attr  :uuid, hash_key: true
  #   integer_attr :id,   range_key: true
  #   string_attr  :body
  #   end
  #
  #   q = ExampleTable.build_query.key_expr(
  #   ":uuid = ? AND :id > ?", "smpl-uuid", 100
  #   ).complete!
  #   q.to_a # You can use this like any other query result in aws-record
  # @raise [ArgumentError]
  #
  # source://aws-record//lib/aws-record/record/buildable_search.rb#89
  def key_expr(statement_str, *subs); end

  # Allows you to set a page size limit on each query or scan request.
  #
  # source://aws-record//lib/aws-record/record/buildable_search.rb#174
  def limit(size); end

  # Allows you to define a callback that will determine the model class
  # to be used for each item, allowing queries to return an ItemCollection
  # with mixed models.  The provided block must return the model class based on
  # any logic on the raw item attributes or `nil` if no model applies and
  # the item should be skipped.  Note: The block only has access to raw item
  # data so attributes must be accessed using their names as defined in the
  # table, not as the symbols defined in the model class(s).
  #
  # @example Scan with heterogeneous results:
  #   # Example model classes
  #   class Model_A
  #   include Aws::Record
  #   set_table_name(TABLE_NAME)
  #
  #   string_attr :uuid, hash_key: true
  #   string_attr :class_name, range_key: true
  #
  #   string_attr :attr_a
  #   end
  #
  #   class Model_B
  #   include Aws::Record
  #   set_table_name(TABLE_NAME)
  #
  #   string_attr :uuid, hash_key: true
  #   string_attr :class_name, range_key: true
  #
  #   string_attr :attr_b
  #   end
  #
  #   # use multi_model_filter to create a query on TABLE_NAME
  #   items = Model_A.build_scan.multi_model_filter do |raw_item_attributes|
  #   case raw_item_attributes['class_name']
  #   when "A" then Model_A
  #   when "B" then Model_B
  #   else
  #   nil
  #   end
  #   end.complete!
  #
  # source://aws-record//lib/aws-record/record/buildable_search.rb#218
  def multi_model_filter(proc = T.unsafe(nil), &block); end

  # If you are querying or scanning on an index, you can specify it with
  # this builder method. Provide the symbol of your index as defined on your
  # model class.
  #
  # source://aws-record//lib/aws-record/record/buildable_search.rb#26
  def on_index(index); end

  # For the scan operation, you can split your scan into multiple segments
  # to be scanned in parallel. If you wish to do this, you can use this
  # builder method to provide the :total_segments of your parallel scan and
  # the :segment number of this scan.
  #
  # @raise [ArgumentError]
  #
  # source://aws-record//lib/aws-record/record/buildable_search.rb#42
  def parallel_scan(opts); end

  # Allows you to define a projection expression for the values returned by
  # a query or scan. See
  # {https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ProjectionExpressions.html
  # the Amazon DynamoDB Developer Guide} for more details on projection expressions.
  # You can use the symbols from your aws-record model class in a projection expression.
  # Keys are always retrieved.
  #
  # @example Scan with a projection expression:
  #   # Example model class
  #   class ExampleTable
  #   include Aws::Record
  #   string_attr  :uuid, hash_key: true
  #   integer_attr :id,   range_key: true
  #   string_attr  :body
  #   map_attr     :metadata
  #   end
  #
  #   scan = ExampleTable.build_scan.projection_expr(
  #   ":body"
  #   ).complete!
  #
  # source://aws-record//lib/aws-record/record/buildable_search.rb#162
  def projection_expr(statement_str); end

  # For a query operation, you can use this to set if you query is in
  # ascending or descending order on your range key. By default, a query is
  # run in ascending order.
  #
  # @raise [ArgumentError]
  #
  # source://aws-record//lib/aws-record/record/buildable_search.rb#56
  def scan_ascending(b); end

  private

  # source://aws-record//lib/aws-record/record/buildable_search.rb#249
  def _apply_values(statement, subs, values); end

  # source://aws-record//lib/aws-record/record/buildable_search.rb#233
  def _key_pass(statement, names); end

  # source://aws-record//lib/aws-record/record/buildable_search.rb#264
  def _next_name; end

  # source://aws-record//lib/aws-record/record/buildable_search.rb#270
  def _next_value; end
end

# source://aws-record//lib/aws-record/record/buildable_search.rb#6
Aws::Record::BuildableSearch::SUPPORTED_OPERATIONS = T.let(T.unsafe(nil), Array)

# source://aws-record//lib/aws-record/record/client_configuration.rb#5
module Aws::Record::ClientConfiguration
  # Configures the Amazon DynamoDB client used by this class and all
  # instances of this class.
  #
  # Please note that this method is also called internally when you first
  # attempt to perform an operation against the remote end, if you have not
  # already configured a client. As such, please read and understand the
  # documentation in the AWS SDK for Ruby around
  # {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/index.html#Configuration configuration}
  # to ensure you understand how default configuration behavior works. When
  # in doubt, call this method to ensure your client is configured the way
  # you want it to be configured.
  #
  # *Note*: {#dynamodb_client} is inherited from a parent model when
  # +configure_client+ is explicitly specified in the parent.
  #
  # @option opts
  # @param opts [Hash] the options you wish to use to create the client.
  #   Note that if you include the option +:client+, all other options
  #   will be ignored. See the documentation for other options in the
  #   {https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#initialize-instance_method
  #   AWS SDK for Ruby}.
  #
  # source://aws-record//lib/aws-record/record/client_configuration.rb#27
  def configure_client(opts = T.unsafe(nil)); end

  # Gets the
  # {https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html Client}
  # instance that Transactions use. When called for the first time, if
  # {#configure_client} has not yet been called, will configure a new
  # client for you with default parameters.
  #
  # *Note*: +dynamodb_client+ is inherited from a parent model when
  # {configure_client} is explicitly specified in the parent.
  #
  # @return [Aws::DynamoDB::Client] the Amazon DynamoDB client instance.
  #
  # source://aws-record//lib/aws-record/record/client_configuration.rb#48
  def dynamodb_client; end

  private

  # source://aws-record//lib/aws-record/record/client_configuration.rb#54
  def _build_client(opts = T.unsafe(nil)); end
end

# This is an identity marshaler, which performs no changes for type casting
# or serialization. It is generally not recommended for use.
#
# source://aws-record//lib/aws-record/record/attribute.rb#105
module Aws::Record::DefaultMarshaler
  class << self
    # source://aws-record//lib/aws-record/record/attribute.rb#110
    def serialize(raw_value, _options = T.unsafe(nil)); end

    # source://aws-record//lib/aws-record/record/attribute.rb#106
    def type_cast(raw_value, _options = T.unsafe(nil)); end
  end
end

# source://aws-record//lib/aws-record/record/dirty_tracking.rb#5
module Aws::Record::DirtyTracking
  mixes_in_class_methods ::Aws::Record::DirtyTracking::DirtyTrackingClassMethods

  # Mark that an attribute is changing. This is useful in situations
  # where it is necessary to track that the value of an
  # attribute is changing in-place.
  #
  # @example
  #   class Model
  #   include Aws::Record
  #   integer_attr :id,   hash_key: true
  #   string_attr  :name
  #   end
  #
  #   model.name        # => 'Alex'
  #   model.name_dirty? # => false
  #   model.name_was    # => 'Alex'
  #
  #   model.name << 'i'
  #   model.name        # => 'Alexi'
  #
  #   # The change was made in place. Since the String instance representing
  #   # the value of name is the same as it was originally, the change is not
  #   # detected.
  #   model.name_dirty? # => false
  #   model.name_was    # => 'Alexi'
  #
  #   model.name_dirty!
  #   model.name_dirty? # => true
  #   model.name_was    # => 'Alexi'
  #
  #   model.name << 's'
  #   model.name        # => 'Alexis'
  #   model.name_dirty? # => true
  #   model.name_was    # => 'Alexi'
  # @param name [String, Symbol] The name of the attribute to mark as
  #   changing.
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#84
  def attribute_dirty!(name); end

  # Returns +true+ if the specified attribute has any dirty changes, +false+ otherwise.
  #
  # @example
  #   class Model
  #   include Aws::Record
  #   integer_attr :id, hash_key: true
  #   string_attr  :name
  #   end
  #
  #   model.name_dirty? # => false
  #   model.name     # => 'Alex'
  #   model.name = 'Nick'
  #   model.name_dirty? # => true
  # @param name [String, Symbol] The name of the attribute to to check for dirty changes.
  # @return [Boolean] +true+ if the specified attribute has any dirty changes, +false+ otherwise.
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#26
  def attribute_dirty?(name); end

  # Returns the original value of the specified attribute.
  #
  # @example
  #   class Model
  #   include Aws::Record
  #   integer_attr :id,   hash_key: true
  #   string_attr  :name
  #   end
  #
  #   model.name         # => 'Alex'
  #   model.name = 'Nick'
  #   model.name_was     # => 'Alex'
  # @param name [String, Symbol] The name of the attribute to retrieve the original value of.
  # @return [Object] The original value of the specified attribute.
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#45
  def attribute_was(name); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#254
  def clean!; end

  # Returns +true+ if the model has been destroyed, +false+ otherwise.
  #
  # @example
  #   class Model
  #   include Aws::Record
  #   integer_attr :id, hash_key: true
  #   string_attr  :name
  #   end
  #
  #   model = Model.new
  #   model.destroyed? # => false
  #   model.save
  #   model.destroyed? # => false
  #   model.delete!
  #   model.destroyed? # => true
  # @return [Boolean] +true+ if the model has been destroyed, +false+
  #   otherwise.
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#187
  def destroyed?; end

  # Returns an array with the name of the attributes with dirty changes.
  #
  # @example
  #   class Model
  #   include Aws::Record
  #   integer_attr :id, hash_key: true
  #   string_attr  :name
  #   end
  #
  #   model.dirty # => []
  #   model.name  # => 'Alex'
  #   model.name = 'Nick'
  #   model.dirty # => ['name']
  # @return [Array] The names of attributes with dirty changes.
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#103
  def dirty; end

  # Returns +true+ if any attributes have dirty changes, +false+ otherwise.
  #
  # @example
  #   class Model
  #   include Aws::Record
  #   integer_attr :id, hash_key: true
  #   string_attr  :name
  #   end
  #
  #   model.dirty? # => false
  #   model.name   # => 'Alex'
  #   model.name = 'Nick'
  #   model.dirty? # => true
  # @return [Boolean] +true+ if any attributes have dirty changes, +false+
  #   otherwise.
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#123
  def dirty?; end

  # Returns +true+ if the model is newly initialized, +false+ otherwise.
  #
  # @example
  #   class Model
  #   include Aws::Record
  #   integer_attr :id, hash_key: true
  #   string_attr  :name
  #   end
  #
  #   model = Model.new
  #   model.new_record? # => true
  #   model.save
  #   model.new_record? # => false
  # @return [Boolean] +true+ if the model is newly initialized, +false+
  #   otherwise.
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#165
  def new_record?; end

  # Returns +true+ if the model is not new and has not been deleted, +false+ otherwise.
  #
  # @example
  #   class Model
  #   include Aws::Record
  #   integer_attr :id, hash_key: true
  #   string_attr  :name
  #   end
  #
  #   model = Model.new
  #   model.persisted? # => false
  #   model.save
  #   model.persisted? # => true
  #   model.delete!
  #   model.persisted? # => false
  # @return [Boolean] +true+ if the model is not new and has not been deleted, +false+
  #   otherwise.
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#145
  def persisted?; end

  # @raise [Errors::NotFound]
  # @return [self] Returns the item instance.
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#198
  def reload!; end

  # Restores all attributes to their original values.
  #
  # @example
  #   class Model
  #   include Aws::Record
  #   integer_attr :id, hash_key: true
  #   string_attr  :name
  #   end
  #
  #   model.name # => 'Alex'
  #   model.name = 'Nick'
  #   model.rollback!
  #   model.name # => 'Alex'
  # @param names [Array, String, Symbol] The names of attributes to restore.
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#249
  def rollback!(names = T.unsafe(nil)); end

  # Restores the attribute specified to its original value.
  #
  # @example
  #   class Model
  #   include Aws::Record
  #   integer_attr :id, hash_key: true
  #   string_attr  :name
  #   end
  #
  #   model.name # => 'Alex'
  #   model.name = 'Nick'
  #   model.rollback_attribute!(:name)
  #   model.name # => 'Alex'
  # @param name [String, Symbol] The name of the attribute to restore
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#230
  def rollback_attribute!(name); end

  # @private
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#259
  def save(*_arg0); end

  class << self
    # @private
    #
    # source://aws-record//lib/aws-record/record/dirty_tracking.rb#6
    def included(sub_class); end
  end
end

# source://aws-record//lib/aws-record/record/dirty_tracking.rb#263
module Aws::Record::DirtyTracking::DirtyTrackingClassMethods
  private

  # @private
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#272
  def _define_attr_methods(name); end

  # @private
  #
  # source://aws-record//lib/aws-record/record/dirty_tracking.rb#267
  def build_item_from_resp(*_arg0); end
end

# source://aws-record//lib/aws-record/record/errors.rb#5
module Aws::Record::Errors; end

# Raised when a conditional write fails.
# Provides access to the original ConditionalCheckFailedException error
# which may have item data if the return values option was used.
#
# source://aws-record//lib/aws-record/record/errors.rb#21
class Aws::Record::Errors::ConditionalWriteFailed < ::Aws::Record::Errors::RecordError
  # @return [ConditionalWriteFailed] a new instance of ConditionalWriteFailed
  #
  # source://aws-record//lib/aws-record/record/errors.rb#22
  def initialize(message, original_error); end

  # @return [Aws::DynamoDB::Errors::ConditionalCheckFailedException]
  #
  # source://aws-record//lib/aws-record/record/errors.rb#28
  def original_error; end
end

# Raised when you attempt a table migration and your model class is
# invalid.
#
# source://aws-record//lib/aws-record/record/errors.rb#48
class Aws::Record::Errors::InvalidModel < ::RuntimeError; end

# Raised when a required key attribute is missing from an item when
# persistence is attempted.
#
# source://aws-record//lib/aws-record/record/errors.rb#12
class Aws::Record::Errors::KeyMissing < ::Aws::Record::Errors::RecordError; end

# source://aws-record//lib/aws-record/record/errors.rb#54
class Aws::Record::Errors::MissingRequiredConfiguration < ::RuntimeError; end

# Raised when an attribute is defined that has a name collision with an
# existing attribute.
#
# source://aws-record//lib/aws-record/record/errors.rb#36
class Aws::Record::Errors::NameCollision < ::RuntimeError; end

# Raised when you attempt to load a record from the database, but it does
# not exist there.
#
# source://aws-record//lib/aws-record/record/errors.rb#16
class Aws::Record::Errors::NotFound < ::Aws::Record::Errors::RecordError; end

# RecordErrors relate to the persistence of items. They include both
# client errors and certain validation errors.
#
# source://aws-record//lib/aws-record/record/errors.rb#8
class Aws::Record::Errors::RecordError < ::RuntimeError; end

# Raised when you attempt to create an attribute which has a name that
# conflicts with reserved names (generally, defined method names). If you
# see this error, you should change the attribute name in the model. If
# the database uses this name, you can take advantage of the
# +:database_attribute_name+ option in
# {Aws::Record::Attributes::ClassMethods#attr #attr}
#
# source://aws-record//lib/aws-record/record/errors.rb#44
class Aws::Record::Errors::ReservedName < ::RuntimeError; end

# Raised when you attempt update/delete operations on a table that does
# not exist.
#
# source://aws-record//lib/aws-record/record/errors.rb#52
class Aws::Record::Errors::TableDoesNotExist < ::RuntimeError; end

# Raised when you attempt to combine your own condition expression with
# the auto-generated condition expression from a "safe put" from saving
# a new item in a transactional write operation. The path forward until
# this case is supported is to use a plain "put" call, and to include
# the key existance check yourself in your condition expression if you
# wish to do so.
#
# source://aws-record//lib/aws-record/record/errors.rb#62
class Aws::Record::Errors::TransactionalSaveConditionCollision < ::RuntimeError; end

# Raised when you attempt to combine your own update expression with
# the update expression auto-generated from updates to an item's
# attributes. The path forward until this case is supported is to
# perform attribute updates yourself in your update expression if you
# wish to do so.
#
# source://aws-record//lib/aws-record/record/errors.rb#69
class Aws::Record::Errors::UpdateExpressionCollision < ::RuntimeError; end

# Raised when a validation hook call to +:valid?+ fails.
#
# source://aws-record//lib/aws-record/record/errors.rb#32
class Aws::Record::Errors::ValidationError < ::Aws::Record::Errors::RecordError; end

# source://aws-record//lib/aws-record/record/item_collection.rb#5
class Aws::Record::ItemCollection
  include ::Enumerable

  # @return [ItemCollection] a new instance of ItemCollection
  #
  # source://aws-record//lib/aws-record/record/item_collection.rb#8
  def initialize(search_method, search_params, model, client); end

  # Provides an enumeration of the results of a query or scan operation on
  # your table, automatically converted into item classes.
  #
  # WARNING: This will enumerate over your entire partition in the case of
  # query, and over your entire table in the case of scan, save for key and
  # filter expressions used. This means that enumerable operations that
  # iterate over the full result set could make many network calls, or use a
  # lot of memory to build response objects. Use with caution.
  #
  # @return [Enumerable<Aws::Record>] an enumeration over the results of
  #   your query or scan request. These results are automatically converted
  #   into items on your behalf.
  #
  # source://aws-record//lib/aws-record/record/item_collection.rb#28
  def each(&block); end

  # Checks if the query/scan result is completely blank.
  #
  # WARNING: This can and will query your entire partition, or scan your
  # entire table, if no results are found. Especially if your table is
  # large, use this with extreme caution.
  #
  # @return [Boolean] true if the query/scan result is empty, false
  #   otherwise.
  #
  # source://aws-record//lib/aws-record/record/item_collection.rb#72
  def empty?; end

  # Provides the pagination key most recently used by the underlying client.
  # This can be useful in the case where you're exposing pagination to an
  # outside caller, and want to be able to "resume" your scan in a new call
  # without starting over.
  #
  # @return [Hash] a hash representing an attribute key/value pair, suitable
  #   for use as the +exclusive_start_key+ in another query or scan
  #   operation. If there are no more pages in the result, will be nil.
  #
  # source://aws-record//lib/aws-record/record/item_collection.rb#60
  def last_evaluated_key; end

  # Provides the first "page" of responses from your query operation. This
  # will only make a single client call, and will provide the items, if any
  # exist, from that response. It will not attempt to follow up on
  # pagination tokens, so this is not guaranteed to include all items that
  # match your search.
  #
  # @return [Array<Aws::Record>] an array of the record items found in the
  #   first page of responses from the query or scan call.
  #
  # source://aws-record//lib/aws-record/record/item_collection.rb#46
  def page; end

  private

  # source://aws-record//lib/aws-record/record/item_collection.rb#81
  def _build_items_from_response(items, model); end

  # source://aws-record//lib/aws-record/record/item_collection.rb#99
  def items; end
end

# @api private
#
# source://aws-record//lib/aws-record/record/item_data.rb#6
class Aws::Record::ItemData
  # @api private
  # @return [ItemData] a new instance of ItemData
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#7
  def initialize(model_attributes, opts); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#71
  def attribute_dirty!(name); end

  # @api private
  # @return [Boolean]
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#58
  def attribute_dirty?(name); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#67
  def attribute_was(name); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#98
  def build_save_hash; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#45
  def clean!; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#19
  def destroyed; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#19
  def destroyed=(_arg0); end

  # @api private
  # @return [Boolean]
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#33
  def destroyed?; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#75
  def dirty; end

  # @api private
  # @return [Boolean]
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#82
  def dirty?; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#21
  def get_attribute(name); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#94
  def hash_copy; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#19
  def new_record; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#19
  def new_record=(_arg0); end

  # @api private
  # @return [Boolean]
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#29
  def new_record?; end

  # @api private
  # @return [Boolean]
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#37
  def persisted?; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#110
  def populate_default_values; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#41
  def raw_value(name); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#86
  def rollback_attribute!(name); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#25
  def set_attribute(name, value); end

  private

  # @api private
  #
  # source://aws-record//lib/aws-record/record/item_data.rb#121
  def _deep_copy(obj); end
end

# source://aws-record//lib/aws-record/record/item_operations.rb#5
module Aws::Record::ItemOperations
  mixes_in_class_methods ::Aws::Record::ItemOperations::ItemOperationsClassMethods

  # Assigns the attributes provided onto the model.
  #
  # @example Usage Example
  #   class MyModel
  #   include Aws::Record
  #   integer_attr :uuid,   hash_key: true
  #   string_attr  :name, range_key: true
  #   integer_attr :age
  #   float_attr   :height
  #   end
  #
  #   model = MyModel.new(id: 4, name: "John", age: 4, height: 70.5)
  #   model.age    # => 4
  #   model.height # => 70.5
  #   model.save
  #   model.dirty? # => false
  #
  #   model.assign_attributes(age: 5, height: 150.75)
  #   model.age    # => 5
  #   model.height # => 150.75
  #   model.dirty? # => true
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#108
  def assign_attributes(opts); end

  # Deletes the item instance that matches the key values of this item
  # instance in Amazon DynamoDB. Uses the
  # {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#delete_item-instance_method
  # Aws::DynamoDB::Client#delete_item} API.
  #
  # @param opts [Hash] Options to pass through to the
  #   {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#delete_item-instance_method
  #   Aws::DynamoDB::Client#delete_item} call.
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#207
  def delete!(opts = T.unsafe(nil)); end

  # Validates and generates the key values necessary for API operations such as the
  # {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#delete_item-instance_method
  # Aws::DynamoDB::Client#delete_item} operation.
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#219
  def key_values; end

  # Saves this instance of an item to Amazon DynamoDB. If this item is "new"
  # as defined by having new or altered key attributes, will attempt a
  # conditional
  # {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#put_item-instance_method
  # Aws::DynamoDB::Client#put_item} call, which will not overwrite an
  # existing item. If the item only has altered non-key attributes, will perform an
  # {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#update_item-instance_method
  # Aws::DynamoDB::Client#update_item} call. Uses this item instance's attributes
  # in order to build the request on your behalf.
  #
  # You can use the +:force+ option to perform a simple put/overwrite
  # without conditional validation or update logic.
  #
  # @option opts
  # @param opts [Hash] Options to pass through to the
  #   {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#put_item-instance_method
  #   Aws::DynamoDB::Client#put_item} call or the
  #   {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#update_item-instance_method
  #   Aws::DynamoDB::Client#update_item} call. +:put_item+ is used when
  #   +:force+ is true or when the item is new. +:update_item+ is used when
  #   the item is not new.
  # @return false if the record is invalid as defined by an attempt to call
  #   +valid?+ on this item, if that method exists. Otherwise, returns client
  #   call return value.
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#76
  def save(opts = T.unsafe(nil)); end

  # Saves this instance of an item to Amazon DynamoDB. If this item is "new"
  # as defined by having new or altered key attributes, will attempt a
  # conditional
  # {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#put_item-instance_method
  # Aws::DynamoDB::Client#put_item} call, which will not overwrite an existing
  # item. If the item only has altered non-key attributes, will perform an
  # {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#update_item-instance_method
  # Aws::DynamoDB::Client#update_item} call. Uses this item instance's attributes
  # in order to build the request on your behalf.
  #
  # You can use the +:force+ option to perform a simple put/overwrite
  # without conditional validation or update logic.
  #
  # @option opts
  # @param opts [Hash] Options to pass through to the
  #   {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#put_item-instance_method
  #   Aws::DynamoDB::Client#put_item} call or the
  #   {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#update_item-instance_method
  #   Aws::DynamoDB::Client#update_item} call. +:put_item+ is used when
  #   +:force+ is true or when the item is new. +:update_item+ is used when
  #   the item is not new.
  # @raise [Aws::Record::Errors::KeyMissing] if a required key attribute
  #   does not have a value within this item instance.
  # @raise [Aws::Record::Errors::ConditionalWriteFailed] if a conditional
  #   put fails because the item exists on the remote end.
  # @raise [Aws::Record::Errors::ValidationError] if the item responds to
  #   +:valid?+ and that call returned false. In such a case, checking root
  #   cause is dependent on the validation library you are using.
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#42
  def save!(opts = T.unsafe(nil)); end

  # Validates key values and returns a hash consisting of the parameters
  # to save the record using the
  # {https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#batch_write_item-instance_method
  # Aws::DynamoDB::Client#batch_write_item} operation.
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#233
  def save_values; end

  # Mass assigns the attributes to the model and then performs a save
  #
  # You can use the +:force+ option to perform a simple put/overwrite
  # without conditional validation or update logic.
  #
  # Note that aws-record allows you to change your model's key values,
  # but this will be interpreted as persisting a new item to your DynamoDB
  # table
  #
  # @example Usage Example
  #   class MyModel
  #   include Aws::Record
  #   integer_attr :uuid,   hash_key: true
  #   string_attr  :name, range_key: true
  #   integer_attr :age
  #   float_attr   :height
  #   end
  #
  #   model = MyModel.new(id: 4, name: "John", age: 4, height: 70.5)
  #   model.age    # => 4
  #   model.height # => 70.5
  #   model.save
  #   model.dirty? # => false
  #
  #   model.update(age: 5, height: 150.75)
  #   model.age    # => 5
  #   model.height # => 150.75
  #   model.dirty? # => false
  # @option opts
  # @param new_params [Hash] Contains the new parameters for the model.
  # @param opts [Hash] Options to pass through to the
  #   {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#put_item-instance_method
  #   Aws::DynamoDB::Client#put_item} call or the
  #   {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#update_item-instance_method
  #   Aws::DynamoDB::Client#update_item} call. +:put_item+ is used when
  #   +:force+ is true or when the item is new. +:update_item+ is used when
  #   the item is not new.
  # @return false if the record is invalid as defined by an attempt to call
  #   +valid?+ on this item, if that method exists. Otherwise, returns client
  #   call return value.
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#164
  def update(new_params, opts = T.unsafe(nil)); end

  # Updates model attributes and validates new values
  #
  # You can use the +:force+ option to perform a simple put/overwrite
  # without conditional validation or update logic.
  #
  # Note that aws-record allows you to change your model's key values,
  # but this will be interpreted as persisting a new item to your DynamoDB
  # table
  #
  # @option opts
  # @param new_params [Hash] Contains the new parameters for the model.
  # @param opts [Hash] Options to pass through to the
  #   {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#put_item-instance_method
  #   Aws::DynamoDB::Client#put_item} call or the
  #   {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#update_item-instance_method
  #   Aws::DynamoDB::Client#update_item} call. +:put_item+ is used when
  #   +:force+ is true or when the item is new. +:update_item+ is used when
  #   the item is not new.
  # @raise [Aws::Record::Errors::ValidationError] if any new values
  #   violate the models validations.
  # @return The update mode if the update is successful
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#194
  def update!(new_params, opts = T.unsafe(nil)); end

  private

  # source://aws-record//lib/aws-record/record/item_operations.rb#295
  def _build_item_for_save; end

  # source://aws-record//lib/aws-record/record/item_operations.rb#338
  def _dirty_changes_for_update; end

  # @return [Boolean]
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#239
  def _invalid_record?(_opts); end

  # source://aws-record//lib/aws-record/record/item_operations.rb#247
  def _perform_save(opts); end

  # @return [Boolean]
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#313
  def expect_new_item?; end

  # source://aws-record//lib/aws-record/record/item_operations.rb#306
  def missing_key_values; end

  # source://aws-record//lib/aws-record/record/item_operations.rb#320
  def prevent_overwrite_expression; end

  # @raise [Errors::KeyMissing]
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#301
  def validate_key_values; end

  class << self
    # @api private
    # @private
    #
    # source://aws-record//lib/aws-record/record/item_operations.rb#7
    def included(sub_class); end
  end
end

# source://aws-record//lib/aws-record/record/item_operations.rb#345
module Aws::Record::ItemOperations::ItemOperationsClassMethods
  # @example Usage Example
  #   class MyModel
  #   include Aws::Record
  #   integer_attr :id,   hash_key: true
  #   string_attr  :name, range_key: true
  #   end
  #
  #   MyModel.find(id: 1, name: "First")
  # @param opts [Hash] attribute-value pairs for the key you wish to
  #   search for.
  # @raise [Aws::Record::Errors::KeyMissing] if your option parameters do
  #   not include all table keys.
  # @return [Aws::Record] builds and returns an instance of your model.
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#471
  def find(opts); end

  # Provides support for the
  # {https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#batch_get_item-instance_method
  # Aws::DynamoDB::Client#batch_get_item} for your model.
  #
  # This method will take a list of keys and return an instance of +Aws::Record::BatchRead+
  #
  # See {Batch.read} for more details.
  #
  # @example Usage Example
  #   class MyModel
  #   include Aws::Record
  #   integer_attr :id,   hash_key: true
  #   string_attr  :name, range_key: true
  #   end
  #
  #   # returns a homogenous list of items
  #   foo_items = MyModel.find_all(
  #   [
  #   {id: 1, name: 'n1'},
  #   {id: 2, name: 'n2'}
  #   ])
  # @param keys [Array] an array of item key hashes you wish to search for.
  # @raise [Aws::Record::Errors::KeyMissing] if your param hashes do not
  #   include all the keys defined in model.
  # @raise [ArgumentError] if the provided keys are a duplicate.
  # @return [Aws::Record::BatchRead] An instance that contains modeled items
  #   from the +BatchGetItem+ result and stores unprocessed keys to be
  #   manually processed later.
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#555
  def find_all(keys); end

  # Note that +#find_with_opts+ will pass through all options other than
  # +:key+ unaltered to the underlying +Aws::DynamoDB::Client#get_item+
  # request. You should ensure that you have an aws-sdk gem version which
  # supports the options you are including, and avoid adding options not
  # recognized by the underlying client to avoid runtime exceptions.
  #
  # @example Usage Example
  #   class MyModel
  #   include Aws::Record
  #   integer_attr :id,   hash_key: true
  #   string_attr  :name, range_key: true
  #   end
  #
  #   MyModel.find_with_opts(
  #   key: { id: 1, name: "First" },
  #   consistent_read: true
  #   )
  # @option opts
  # @param opts [Hash] Options to pass through to the
  #   {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#get_item-instance_method
  #   Aws::DynamoDB::Client#get_item} request. The +:key+ option is a
  #   special case where attributes are serialized and translated for you
  #   similar to the #find method.
  # @raise [Aws::Record::Errors::KeyMissing] if your option parameters do
  #   not include all table keys.
  # @return [Aws::Record] builds and returns an instance of your model.
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#505
  def find_with_opts(opts); end

  # Used in {Transactions.transact_find}, which is a way to run
  # transactional find across multiple DynamoDB items, including transactions
  # which get items across multiple actual or virtual tables.
  #
  # This operation provide extra metadata used to marshal your items after retrieval.
  #
  # See {Transactions.transact_find transact_find} for more info and usage example.
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#395
  def tfind_opts(opts); end

  # Allows you to build a "check" expression for use in transactional
  # write operations.
  #
  # See {Transactions.transact_write transact_write} for more info.
  #
  # @example Usage Example
  #   check_exp = Model.transact_check_expression(
  #   key: { uuid: "foo" },
  #   condition_expression: "size(#T) <= :v",
  #   expression_attribute_names: {
  #   "#T" => "body"
  #   },
  #   expression_attribute_values: {
  #   ":v" => 1024
  #   }
  #   )
  # @param opts [Hash] Options matching the :condition_check contents in
  #   the
  #   {https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#transact_write_items-instance_method
  #   Aws::DynamoDB::Client#transact_write_items} API, with the exception that
  #   keys will be marshalled for you, and the table name will be provided
  #   for you by the operation.
  # @return [Hash] Options suitable to be used as a check expression when
  #   calling the +#transact_write+ operation.
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#371
  def transact_check_expression(opts); end

  # Provides a way to run a transactional find across multiple DynamoDB
  # items, including transactions which get items across multiple actual
  # or virtual tables.
  #
  # @example Usage Example
  #   class Table
  #   include Aws::Record
  #   string_attr :hk, hash_key: true
  #   string_attr :rk, range_key: true
  #   end
  #
  #   results = Table.transact_find(
  #   transact_items: [
  #   {key: { hk: "hk1", rk: "rk1"}},
  #   {key: { hk: "hk2", rk: "rk2"}}
  #   ]
  #   ) # => results.responses contains nil or instances of Table
  # @option opts
  # @param opts [Hash] Options to pass through to
  #   {https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#transact_get_items-instance_method
  #   Aws::DynamoDB::Client#transact_get_items}, with the exception of the
  #   :transact_items array, which uses the +#tfind_opts+ operation on
  #   your model class to provide extra metadata used to marshal your
  #   items after retrieval.
  # @return [OpenStruct] Structured like the client API response from
  #   +#transact_get_items+, except that the +responses+ member contains
  #   +Aws::Record+ items marshaled into the model class used to call
  #   this method. See the usage example.
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#446
  def transact_find(opts); end

  # Performs an
  # {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#update_item-instance_method
  # Aws::DynamoDB::Client#update_item} call immediately on the table,
  # using the attribute key/value pairs provided.
  #
  # @example Usage Example
  #   class MyModel
  #   include Aws::Record
  #   integer_attr :id,   hash_key: true
  #   string_attr  :name, range_key: true
  #   string_attr  :body
  #   boolean_attr :sir_not_appearing_in_this_example
  #   end
  #
  #   MyModel.update(id: 1, name: "First", body: "Hello!")
  # @param new_params [Hash] attribute-value pairs for the update operation
  #   you wish to perform. You must include all key attributes for a valid
  #   call, then you may optionally include any other attributes that you
  #   wish to update.
  # @param opts [Hash] Options to pass through to the
  #   {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#update_item-instance_method
  #   Aws::DynamoDB::Client#update_item} call.
  # @raise [Aws::Record::Errors::KeyMissing] if your option parameters do
  #   not include all table keys.
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#589
  def update(new_params, opts = T.unsafe(nil)); end

  private

  # source://aws-record//lib/aws-record/record/item_operations.rb#610
  def _build_update_expression(attr_value_pairs); end

  # source://aws-record//lib/aws-record/record/item_operations.rb#643
  def _merge_update_expression_opts(update_expression_opts, pass_through_opts); end

  # @return [Boolean]
  #
  # source://aws-record//lib/aws-record/record/item_operations.rb#665
  def _update_type_remove?(attribute, value); end

  # source://aws-record//lib/aws-record/record/item_operations.rb#655
  def build_item_from_resp(resp); end
end

# @api private
#
# source://aws-record//lib/aws-record/record/key_attributes.rb#6
class Aws::Record::KeyAttributes
  # @api private
  # @return [KeyAttributes] a new instance of KeyAttributes
  #
  # source://aws-record//lib/aws-record/record/key_attributes.rb#9
  def initialize(model_attributes); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/key_attributes.rb#14
  def hash_key; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/key_attributes.rb#30
  def hash_key=(value); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/key_attributes.rb#18
  def hash_key_attribute; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/key_attributes.rb#7
  def keys; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/key_attributes.rb#22
  def range_key; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/key_attributes.rb#35
  def range_key=(value); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/key_attributes.rb#26
  def range_key_attribute; end
end

# source://aws-record//lib/aws-record/record/marshalers/string_marshaler.rb#5
module Aws::Record::Marshalers
  # source://aws-record//lib/aws-record/record/marshalers/numeric_set_marshaler.rb#6
  def initialize(opts = T.unsafe(nil)); end
end

# source://aws-record//lib/aws-record/record/marshalers/boolean_marshaler.rb#6
class Aws::Record::Marshalers::BooleanMarshaler
  # @return [BooleanMarshaler] a new instance of BooleanMarshaler
  #
  # source://aws-record//lib/aws-record/record/marshalers/boolean_marshaler.rb#7
  def initialize(opts = T.unsafe(nil)); end

  # source://aws-record//lib/aws-record/record/marshalers/boolean_marshaler.rb#22
  def serialize(raw_value); end

  # source://aws-record//lib/aws-record/record/marshalers/boolean_marshaler.rb#11
  def type_cast(raw_value); end
end

# source://aws-record//lib/aws-record/record/marshalers/date_marshaler.rb#8
class Aws::Record::Marshalers::DateMarshaler
  # @return [DateMarshaler] a new instance of DateMarshaler
  #
  # source://aws-record//lib/aws-record/record/marshalers/date_marshaler.rb#9
  def initialize(opts = T.unsafe(nil)); end

  # source://aws-record//lib/aws-record/record/marshalers/date_marshaler.rb#26
  def serialize(raw_value); end

  # source://aws-record//lib/aws-record/record/marshalers/date_marshaler.rb#13
  def type_cast(raw_value); end
end

# source://aws-record//lib/aws-record/record/marshalers/date_time_marshaler.rb#8
class Aws::Record::Marshalers::DateTimeMarshaler
  # @return [DateTimeMarshaler] a new instance of DateTimeMarshaler
  #
  # source://aws-record//lib/aws-record/record/marshalers/date_time_marshaler.rb#9
  def initialize(opts = T.unsafe(nil)); end

  # source://aws-record//lib/aws-record/record/marshalers/date_time_marshaler.rb#23
  def serialize(raw_value); end

  # source://aws-record//lib/aws-record/record/marshalers/date_time_marshaler.rb#14
  def type_cast(raw_value); end

  private

  # source://aws-record//lib/aws-record/record/marshalers/date_time_marshaler.rb#37
  def _format(raw_value); end
end

# source://aws-record//lib/aws-record/record/marshalers/epoch_time_marshaler.rb#8
class Aws::Record::Marshalers::EpochTimeMarshaler
  # @return [EpochTimeMarshaler] a new instance of EpochTimeMarshaler
  #
  # source://aws-record//lib/aws-record/record/marshalers/epoch_time_marshaler.rb#9
  def initialize(opts = T.unsafe(nil)); end

  # source://aws-record//lib/aws-record/record/marshalers/epoch_time_marshaler.rb#22
  def serialize(raw_value); end

  # source://aws-record//lib/aws-record/record/marshalers/epoch_time_marshaler.rb#13
  def type_cast(raw_value); end

  private

  # source://aws-record//lib/aws-record/record/marshalers/epoch_time_marshaler.rb#36
  def _format(raw_value); end
end

# source://aws-record//lib/aws-record/record/marshalers/float_marshaler.rb#6
class Aws::Record::Marshalers::FloatMarshaler
  # @return [FloatMarshaler] a new instance of FloatMarshaler
  #
  # source://aws-record//lib/aws-record/record/marshalers/float_marshaler.rb#7
  def initialize(opts = T.unsafe(nil)); end

  # source://aws-record//lib/aws-record/record/marshalers/float_marshaler.rb#22
  def serialize(raw_value); end

  # source://aws-record//lib/aws-record/record/marshalers/float_marshaler.rb#11
  def type_cast(raw_value); end
end

# source://aws-record//lib/aws-record/record/marshalers/integer_marshaler.rb#6
class Aws::Record::Marshalers::IntegerMarshaler
  # @return [IntegerMarshaler] a new instance of IntegerMarshaler
  #
  # source://aws-record//lib/aws-record/record/marshalers/integer_marshaler.rb#7
  def initialize(opts = T.unsafe(nil)); end

  # source://aws-record//lib/aws-record/record/marshalers/integer_marshaler.rb#22
  def serialize(raw_value); end

  # source://aws-record//lib/aws-record/record/marshalers/integer_marshaler.rb#11
  def type_cast(raw_value); end
end

# source://aws-record//lib/aws-record/record/marshalers/date_marshaler.rb#38
module Aws::Record::Marshalers::Iso8601Formatter
  class << self
    # source://aws-record//lib/aws-record/record/marshalers/time_marshaler.rb#52
    def format(time); end
  end
end

# source://aws-record//lib/aws-record/record/marshalers/list_marshaler.rb#6
class Aws::Record::Marshalers::ListMarshaler
  # @return [ListMarshaler] a new instance of ListMarshaler
  #
  # source://aws-record//lib/aws-record/record/marshalers/list_marshaler.rb#7
  def initialize(opts = T.unsafe(nil)); end

  # source://aws-record//lib/aws-record/record/marshalers/list_marshaler.rb#28
  def serialize(raw_value); end

  # source://aws-record//lib/aws-record/record/marshalers/list_marshaler.rb#11
  def type_cast(raw_value); end
end

# source://aws-record//lib/aws-record/record/marshalers/map_marshaler.rb#6
class Aws::Record::Marshalers::MapMarshaler
  # @return [MapMarshaler] a new instance of MapMarshaler
  #
  # source://aws-record//lib/aws-record/record/marshalers/map_marshaler.rb#7
  def initialize(opts = T.unsafe(nil)); end

  # source://aws-record//lib/aws-record/record/marshalers/map_marshaler.rb#28
  def serialize(raw_value); end

  # source://aws-record//lib/aws-record/record/marshalers/map_marshaler.rb#11
  def type_cast(raw_value); end
end

# source://aws-record//lib/aws-record/record/marshalers/numeric_set_marshaler.rb#10
class Aws::Record::Marshalers::NumericSetMarshaler
  # source://aws-record//lib/aws-record/record/marshalers/numeric_set_marshaler.rb#28
  def serialize(raw_value); end

  # source://aws-record//lib/aws-record/record/marshalers/numeric_set_marshaler.rb#11
  def type_cast(raw_value); end

  private

  # source://aws-record//lib/aws-record/record/marshalers/numeric_set_marshaler.rb#44
  def _as_numeric(set); end
end

# source://aws-record//lib/aws-record/record/marshalers/string_marshaler.rb#6
class Aws::Record::Marshalers::StringMarshaler
  # @return [StringMarshaler] a new instance of StringMarshaler
  #
  # source://aws-record//lib/aws-record/record/marshalers/string_marshaler.rb#7
  def initialize(opts = T.unsafe(nil)); end

  # source://aws-record//lib/aws-record/record/marshalers/string_marshaler.rb#22
  def serialize(raw_value); end

  # source://aws-record//lib/aws-record/record/marshalers/string_marshaler.rb#11
  def type_cast(raw_value); end
end

# source://aws-record//lib/aws-record/record/marshalers/string_set_marshaler.rb#6
class Aws::Record::Marshalers::StringSetMarshaler
  # @return [StringSetMarshaler] a new instance of StringSetMarshaler
  #
  # source://aws-record//lib/aws-record/record/marshalers/string_set_marshaler.rb#7
  def initialize(opts = T.unsafe(nil)); end

  # source://aws-record//lib/aws-record/record/marshalers/string_set_marshaler.rb#28
  def serialize(raw_value); end

  # source://aws-record//lib/aws-record/record/marshalers/string_set_marshaler.rb#11
  def type_cast(raw_value); end

  private

  # source://aws-record//lib/aws-record/record/marshalers/string_set_marshaler.rb#44
  def _as_strings(set); end
end

# source://aws-record//lib/aws-record/record/marshalers/time_marshaler.rb#8
class Aws::Record::Marshalers::TimeMarshaler
  # @return [TimeMarshaler] a new instance of TimeMarshaler
  #
  # source://aws-record//lib/aws-record/record/marshalers/time_marshaler.rb#9
  def initialize(opts = T.unsafe(nil)); end

  # source://aws-record//lib/aws-record/record/marshalers/time_marshaler.rb#23
  def serialize(raw_value); end

  # source://aws-record//lib/aws-record/record/marshalers/time_marshaler.rb#14
  def type_cast(raw_value); end

  private

  # source://aws-record//lib/aws-record/record/marshalers/time_marshaler.rb#37
  def _format(raw_value); end
end

# @api private
#
# source://aws-record//lib/aws-record/record/model_attributes.rb#6
class Aws::Record::ModelAttributes
  # @api private
  # @return [ModelAttributes] a new instance of ModelAttributes
  #
  # source://aws-record//lib/aws-record/record/model_attributes.rb#9
  def initialize(model_class); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/model_attributes.rb#30
  def attribute_for(name); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/model_attributes.rb#7
  def attributes; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/model_attributes.rb#42
  def db_to_attribute_name(storage_name); end

  # @api private
  # @return [Boolean]
  #
  # source://aws-record//lib/aws-record/record/model_attributes.rb#38
  def present?(name); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/model_attributes.rb#15
  def register_attribute(name, marshaler, opts); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/model_attributes.rb#23
  def register_superclass_attribute(name, attribute); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/model_attributes.rb#7
  def storage_attributes; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/model_attributes.rb#34
  def storage_name_for(name); end

  private

  # @api private
  #
  # source://aws-record//lib/aws-record/record/model_attributes.rb#68
  def _check_for_naming_collisions(name, storage_name); end

  # @api private
  # @raise [Errors::ReservedName]
  #
  # source://aws-record//lib/aws-record/record/model_attributes.rb#61
  def _check_if_reserved(name); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/model_attributes.rb#48
  def _new_attr_validation(name, attribute); end

  # @api private
  # @raise [ArgumentError]
  #
  # source://aws-record//lib/aws-record/record/model_attributes.rb#54
  def _validate_attr_name(name); end
end

# source://aws-record//lib/aws-record/record/query.rb#5
module Aws::Record::Query
  mixes_in_class_methods ::Aws::Record::Query::QueryClassMethods

  class << self
    # @api private
    # @private
    #
    # source://aws-record//lib/aws-record/record/query.rb#7
    def included(sub_class); end
  end
end

# source://aws-record//lib/aws-record/record/query.rb#11
module Aws::Record::Query::QueryClassMethods
  # This method allows you to build a query using the {Aws::Record::BuildableSearch} DSL.
  #
  # @example Building a simple query:
  #   # Example model class
  #   class ExampleTable
  #   include Aws::Record
  #   string_attr  :uuid, hash_key: true
  #   integer_attr :id,   range_key: true
  #   string_attr  :body
  #   end
  #
  #   q = ExampleTable.build_query.key_expr(
  #   ":uuid = ? AND :id > ?", "smpl-uuid", 100
  #   ).scan_ascending(false).complete!
  #   q.to_a # You can use this like any other query result in aws-record
  #
  # source://aws-record//lib/aws-record/record/query.rb#108
  def build_query; end

  # This method allows you to build a scan using the {Aws::Record::BuildableSearch} DSL.
  #
  # @example Building a simple scan:
  #   # Example model class
  #   class ExampleTable
  #   include Aws::Record
  #   string_attr  :uuid, hash_key: true
  #   integer_attr :id,   range_key: true
  #   string_attr  :body
  #   end
  #
  #   segment_2_scan = ExampleTable.build_scan.filter_expr(
  #   "contains(:body, ?)",
  #   "bacon"
  #   ).scan_ascending(false).parallel_scan(
  #   total_segments: 5,
  #   segment: 2
  #   ).complete!
  #   segment_2_scan.to_a # You can use this like any other query result in aws-record
  #
  # source://aws-record//lib/aws-record/record/query.rb#134
  def build_scan; end

  # This method calls
  # {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#query-instance_method
  # Aws::DynamoDB::Client#query}, populating the +:table_name+ parameter from the model
  # class, and combining this with the other parameters you provide.
  #
  # @example A query with key and filter expressions:
  #   # Example model class
  #   class ExampleTable
  #   include Aws::Record
  #   string_attr  :uuid, hash_key: true
  #   integer_attr :id,   range_key: true
  #   string_attr  :body
  #   end
  #
  #   query = ExampleTable.query(
  #   key_condition_expression: "#H = :h AND #R > :r",
  #   filter_expression: "contains(#B, :b)",
  #   expression_attribute_names: {
  #   "#H" => "uuid",
  #   "#R" => "id",
  #   "#B" => "body"
  #   },
  #   expression_attribute_values: {
  #   ":h" => "123456789uuid987654321",
  #   ":r" => 100,
  #   ":b" => "some substring"
  #   }
  #   )
  #
  #   # You can enumerate over your results.
  #   query.each do |r|
  #   puts "UUID: #{r.uuid}\nID: #{r.id}\nBODY: #{r.body}\n"
  #   end
  # @param opts [Hash] options to pass on to the client call to +#query+.
  #   See the documentation above in the AWS SDK for Ruby V3.
  # @return [Aws::Record::ItemCollection] an enumerable collection of the
  #   query result.
  #
  # source://aws-record//lib/aws-record/record/query.rb#50
  def query(opts); end

  # This method calls
  # {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#scan-instance_method
  # Aws::DynamoDB::Client#scan}, populating the +:table_name+ parameter from the model
  # class, and combining this with the other parameters you provide.
  #
  # @example A scan with a filter expression:
  #   # Example model class
  #   class ExampleTable
  #   include Aws::Record
  #   string_attr  :uuid, hash_key: true
  #   integer_attr :id,   range_key: true
  #   string_attr  :body
  #   end
  #
  #   scan = ExampleTable.scan(
  #   filter_expression: "contains(#B, :b)",
  #   expression_attribute_names: {
  #   "#B" => "body"
  #   },
  #   expression_attribute_values: {
  #   ":b" => "some substring"
  #   }
  #   )
  #
  #   # You can enumerate over your results.
  #   scan.each do |r|
  #   puts "UUID: #{r.uuid}\nID: #{r.id}\nBODY: #{r.body}\n"
  #   end
  # @param opts [Hash] options to pass on to the client call to +#scan+.
  #   See the documentation above in the AWS SDK for Ruby V3.
  # @return [Aws::Record::ItemCollection] an enumerable collection of the
  #   scan result.
  #
  # source://aws-record//lib/aws-record/record/query.rb#88
  def scan(opts = T.unsafe(nil)); end
end

# source://aws-record//lib/aws-record/record.rb#97
module Aws::Record::RecordClassMethods
  # Turns off mutation tracking for all attributes in the model.
  #
  # *Note*: +disable_mutation_tracking+ is inherited from a parent model
  # when it is explicitly specified in the parent.
  #
  # source://aws-record//lib/aws-record/record.rb#215
  def disable_mutation_tracking; end

  # Turns on mutation tracking for all attributes in the model. Note that
  # mutation tracking is on by default, so you generally would not need to
  # call this. It is provided in case there is a need to dynamically turn
  # this feature on and off, though that would be generally discouraged and
  # could cause inaccurate mutation tracking at runtime.
  #
  # *Note*: +enable_mutation_tracking+ is inherited from a parent model
  # when it is explicitly specified in the parent.
  #
  # source://aws-record//lib/aws-record/record.rb#227
  def enable_mutation_tracking; end

  # @raise [Errors::InvalidModel]
  # @return [Boolean]
  #
  # source://aws-record//lib/aws-record/record.rb#241
  def model_valid?; end

  # level, false otherwise.
  #
  # @return [Boolean] true if mutation tracking is enabled at the model
  #
  # source://aws-record//lib/aws-record/record.rb#233
  def mutation_tracking_enabled?; end

  # Fetches the table's provisioned throughput from the associated Amazon
  # DynamoDB table.
  #
  # @raise [Aws::Record::Errors::TableDoesNotExist] if the table name does
  #   not exist in DynamoDB.
  # @return [Hash] a hash containing the +:read_capacity_units+ and
  #   +:write_capacity_units+ of your remote table.
  #
  # source://aws-record//lib/aws-record/record.rb#190
  def provisioned_throughput; end

  # Allows you to set a custom Amazon DynamoDB table name for this model
  # class.
  # === Inheritance Support
  # +table_name+ is inherited from a parent model when it is explicitly specified
  # in the parent.
  #
  # The parent model will need to have +set_table_name+ defined in their model
  # for the child model to inherit the +table_name+.
  # If no +set_table_name+ is defined, the parent and child models will have separate
  # table names based on their class name.
  #
  # If both parent and child models have defined +set_table_name+ in their model,
  # the child model will override the +table_name+ with theirs.
  #
  # @example Setting custom table name for model class
  #   class MyTable
  #   include Aws::Record
  #   set_table_name "prod_MyTable"
  #   end
  #
  #   class MyOtherTable
  #   include Aws::Record
  #   set_table_name "test_MyTable"
  #   end
  #
  #   MyTable.table_name      # => "prod_MyTable"
  #   MyOtherTable.table_name # => "test_MyTable"
  # @example Child model inherits table name from Parent model
  #   class Animal
  #   include Aws::Record
  #   set_table_name "AnimalTable"
  #   end
  #
  #   class Dog < Animal
  #   include Aws::Record
  #   end
  #
  #   Dog.table_name      # => "AnimalTable"
  # @example Child model overrides table name from Parent model
  #   class Animal
  #   include Aws::Record
  #   set_table_name "AnimalTable"
  #   end
  #
  #   class Dog < Animal
  #   include Aws::Record
  #   set_table_name "DogTable"
  #   end
  #
  #   Dog.table_name      # => "DogTable"
  #
  # source://aws-record//lib/aws-record/record.rb#179
  def set_table_name(name); end

  # Checks if the model's table name exists in Amazon DynamoDB.
  #
  # @return [Boolean] true if the table does exist, false if it does not.
  #
  # source://aws-record//lib/aws-record/record.rb#204
  def table_exists?; end

  # Returns the Amazon DynamoDB table name for this model class.
  #
  # By default, this will simply be the name of the class. However, you can
  # also define a custom table name at the class level to be anything that
  # you want.
  #
  # *Note*: +table_name+ is inherited from a parent model when {set_table_name}
  # is explicitly specified in the parent.
  #
  # @example
  #   class MyTable
  #   include Aws::Record
  #   end
  #
  #   class MyOtherTable
  #   include Aws::Record
  #   set_table_name "test_MyTable"
  #   end
  #
  #   MyTable.table_name      # => "MyTable"
  #   MyOtherTable.table_name # => "test_MyTable"
  #
  # source://aws-record//lib/aws-record/record.rb#118
  def table_name; end

  private

  # source://aws-record//lib/aws-record/record.rb#247
  def default_table_name(klass); end
end

# source://aws-record//lib/aws-record/record/secondary_indexes.rb#5
module Aws::Record::SecondaryIndexes
  mixes_in_class_methods ::Aws::Record::SecondaryIndexes::SecondaryIndexesClassMethods

  class << self
    # @api private
    # @private
    #
    # source://aws-record//lib/aws-record/record/secondary_indexes.rb#7
    def included(sub_class); end

    private

    # source://aws-record//lib/aws-record/record/secondary_indexes.rb#14
    def inherit_indexes(klass); end
  end
end

# source://aws-record//lib/aws-record/record/secondary_indexes.rb#23
module Aws::Record::SecondaryIndexes::SecondaryIndexesClassMethods
  # Creates a global secondary index for the model. Learn more about
  # Global Secondary Indexes in the
  # {http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html Amazon DynamoDB Developer Guide}.
  #
  # *Note*: {#global_secondary_indexes} is inherited from a parent model
  # when +global_secondary_index+ is explicitly specified in the parent.
  #
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol] index name for this global secondary index
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/secondary_indexes.rb#59
  def global_secondary_index(name, opts); end

  # Returns hash of global secondary index names to the index's attributes.
  #
  # *Note*: +global_secondary_indexes+ is inherited from a parent model when {#global_secondary_index}
  # is explicitly specified in the parent.
  #
  # @return [Hash] hash of global secondary index names to the index's
  #   attributes.
  #
  # source://aws-record//lib/aws-record/record/secondary_indexes.rb#80
  def global_secondary_indexes; end

  # @return [Hash] hash of the global secondary indexes in a form suitable
  #   for use in a table migration. For example, any attributes which
  #   have a unique database storage name will use that name instead.
  #
  # source://aws-record//lib/aws-record/record/secondary_indexes.rb#94
  def global_secondary_indexes_for_migration; end

  # Creates a local secondary index for the model. Learn more about Local
  # Secondary Indexes in the
  # {http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LSI.html Amazon DynamoDB Developer Guide}.
  #
  # *Note*: {#local_secondary_indexes} is inherited from a parent model
  # when +local_secondary_index+ is explicitly specified in the parent.
  #
  # @option opts
  # @option opts
  # @param name [Symbol] index name for this local secondary index
  # @param opts [Hash]
  #
  # source://aws-record//lib/aws-record/record/secondary_indexes.rb#38
  def local_secondary_index(name, opts); end

  # Returns hash of local secondary index names to the index's attributes.
  #
  # *Note*: +local_secondary_indexes+ is inherited from a parent model when {#local_secondary_index}
  # is explicitly specified in the parent.
  #
  # @return [Hash] hash of local secondary index names to the index's
  #   attributes.
  #
  # source://aws-record//lib/aws-record/record/secondary_indexes.rb#70
  def local_secondary_indexes; end

  # @return [Hash] hash of the local secondary indexes in a form suitable
  #   for use in a table migration. For example, any attributes which
  #   have a unique database storage name will use that name instead.
  #
  # source://aws-record//lib/aws-record/record/secondary_indexes.rb#87
  def local_secondary_indexes_for_migration; end

  private

  # source://aws-record//lib/aws-record/record/secondary_indexes.rb#100
  def _migration_format_indexes(indexes); end

  # source://aws-record//lib/aws-record/record/secondary_indexes.rb#115
  def _si_key_schema(opts); end

  # @raise [ArgumentError]
  #
  # source://aws-record//lib/aws-record/record/secondary_indexes.rb#147
  def _validate_attributes_exist(*attr_names); end

  # @raise [ArgumentError]
  #
  # source://aws-record//lib/aws-record/record/secondary_indexes.rb#137
  def _validate_required_gsi_keys(params); end

  # source://aws-record//lib/aws-record/record/secondary_indexes.rb#129
  def _validate_required_lsi_keys(params); end
end

# +Aws::Record::TableConfig+ provides a DSL for describing and modifying
# the remote configuration of your DynamoDB tables. A table configuration
# object can perform intelligent comparisons and incremental migrations
# versus the current remote configuration, if the table exists, or do a full
# create if it does not. In this manner, table configuration becomes fully
# declarative.
#
# @example A basic model with configuration.
#   class Model
#   include Aws::Record
#   string_attr :uuid, hash_key: true
#   end
#
#   table_config = Aws::Record::TableConfig.define do |t|
#   t.model_class Model
#   t.read_capacity_units 10
#   t.write_capacity_units 5
#   end
# @example A basic model with pay per request billing.
#   class Model
#   include Aws::Record
#   string_attr :uuid, hash_key: true
#   end
#
#   table_config = Aws::Record::TableConfig.define do |t|
#   t.model_class Model
#   t.billing_mode "PAY_PER_REQUEST"
#   end
# @example Running a conditional migration on a basic model.
#   table_config = Aws::Record::TableConfig.define do |t|
#   t.model_class Model
#   t.read_capacity_units 10
#   t.write_capacity_units 5
#   end
#
#   table_config.migrate! unless table_config.compatible?
# @example A model with a global secondary index.
#   class Forum
#   include Aws::Record
#   string_attr     :forum_uuid, hash_key: true
#   integer_attr    :post_id,    range_key: true
#   string_attr     :post_title
#   string_attr     :post_body
#   string_attr     :author_username
#   datetime_attr   :created_date
#   datetime_attr   :updated_date
#   string_set_attr :tags
#   map_attr        :metadata, default_value: {}
#
#   global_secondary_index(
#   :title,
#   hash_key:  :forum_uuid,
#   range_key: :post_title,
#   projection: {
#   projection_type: "ALL"
#   }
#   )
#   end
#
#   table_config = Aws::Record::TableConfig.define do |t|
#   t.model_class Forum
#   t.read_capacity_units 10
#   t.write_capacity_units 5
#
#   t.global_secondary_index(:title) do |i|
#   i.read_capacity_units 5
#   i.write_capacity_units 5
#   end
#   end
# @example A model with a Time to Live attribute
#   class ExpiringTokens
#   string_attr :token_uuid, hash_key: true
#   epoch_time_attr :ttl
#   end
#
#   table_config = Aws::Record::TableConfig.define do |t|
#   t.model_class ExpiringTokens
#   t.read_capacity_units 10
#   t.write_capacity_units 1
#   t.ttl_attribute :ttl
#   end
#
# source://aws-record//lib/aws-record/record/table_config.rb#91
class Aws::Record::TableConfig
  # @api private
  # @return [TableConfig] a new instance of TableConfig
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#155
  def initialize; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#203
  def billing_mode(mode); end

  # Returns the value of attribute client.
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#92
  def client; end

  # Sets the attribute client
  #
  # @param value the value to set the attribute client to.
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#92
  def client=(_arg0); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#184
  def client_options(opts); end

  # Checks the remote table for compatibility. Similar to +#exact_match?+,
  # this will return +false+ if the remote table does not exist. It also
  # checks the keys, declared global secondary indexes, declared attribute
  # definitions, and throughput for exact matches. However, if the remote
  # end has additional attribute definitions and global secondary indexes
  # not defined in your config, will still return +true+. This allows for a
  # check that is friendly to single table inheritance use cases.
  #
  # @return [Boolean] true if remote is compatible, false otherwise.
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#269
  def compatible?; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#189
  def configure_client; end

  # Checks against the remote table's configuration. If the remote table
  # does not exist, guaranteed +false+. Otherwise, will check if the remote
  # throughput, keys, attribute definitions, and global secondary indexes
  # are exactly equal to your declared configuration.
  #
  # @return [Boolean] true if remote is an exact match, false otherwise.
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#282
  def exact_match?; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#177
  def global_secondary_index(name, &block); end

  # Performs a migration, if needed, against the remote table. If
  # +#compatible?+ would return true, the remote table already has the same
  # throughput, key schema, attribute definitions, and global secondary
  # indexes, so no further API calls are made. Otherwise, a DynamoDB table
  # will be created or updated to match your declared configuration.
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#212
  def migrate!; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#162
  def model_class(model); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#167
  def read_capacity_units(units); end

  # @api private
  # @raise [ArgumentError]
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#195
  def ttl_attribute(attribute_symbol); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#172
  def write_capacity_units(units); end

  private

  # source://aws-record//lib/aws-record/record/table_config.rb#513
  def _ad_equal(resp); end

  # source://aws-record//lib/aws-record/record/table_config.rb#518
  def _ad_superset(resp); end

  # source://aws-record//lib/aws-record/record/table_config.rb#350
  def _add_global_secondary_index_throughput(opts, resp_gsis); end

  # source://aws-record//lib/aws-record/record/table_config.rb#610
  def _array_unsorted_eql(a, b); end

  # source://aws-record//lib/aws-record/record/table_config.rb#459
  def _attribute_definitions; end

  # source://aws-record//lib/aws-record/record/table_config.rb#322
  def _compatible_check(resp); end

  # source://aws-record//lib/aws-record/record/table_config.rb#329
  def _create_table_opts; end

  # source://aws-record//lib/aws-record/record/table_config.rb#593
  def _global_secondary_indexes; end

  # source://aws-record//lib/aws-record/record/table_config.rb#538
  def _gsi_equal(resp); end

  # source://aws-record//lib/aws-record/record/table_config.rb#581
  def _gsi_index_names(remote, local); end

  # source://aws-record//lib/aws-record/record/table_config.rb#549
  def _gsi_set_compare(remote_gsis, local_gsis); end

  # source://aws-record//lib/aws-record/record/table_config.rb#525
  def _gsi_superset(resp); end

  # source://aws-record//lib/aws-record/record/table_config.rb#406
  def _gsi_updates(resp); end

  # source://aws-record//lib/aws-record/record/table_config.rb#450
  def _key_schema; end

  # source://aws-record//lib/aws-record/record/table_config.rb#485
  def _keys; end

  # source://aws-record//lib/aws-record/record/table_config.rb#508
  def _keys_equal(resp); end

  # source://aws-record//lib/aws-record/record/table_config.rb#492
  def _throughput_equal(resp); end

  # source://aws-record//lib/aws-record/record/table_config.rb#295
  def _ttl_compatibility_check; end

  # source://aws-record//lib/aws-record/record/table_config.rb#308
  def _ttl_match_check; end

  # source://aws-record//lib/aws-record/record/table_config.rb#396
  def _update_index_opts(resp); end

  # source://aws-record//lib/aws-record/record/table_config.rb#366
  def _update_throughput_opts(resp); end

  # @raise [Errors::MissingRequiredConfiguration]
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#614
  def _validate_required_configuration; end

  class << self
    # Creates a new table configuration, using a DSL in the provided block.
    # The DSL has the following methods:
    # * +#model_class+ A class name reference to the +Aws::Record+ model
    #   class.
    # * +#read_capacity_units+ Sets the read capacity units for the table.
    # * +#write_capacity_units+ Sets the write capacity units for the table.
    # * +#global_secondary_index(index_symbol, &block)+ Defines a global
    #   secondary index with capacity attributes in a block:
    #   * +#read_capacity_units+ Sets the read capacity units for the
    #     index.
    #   * +#write_capacity_units+ Sets the write capacity units for the
    #     index.
    # * +#ttl_attribute+ Sets the attribute ID to be used as the TTL
    #   attribute, and if present, TTL will be enabled for the table.
    # * +#billing_mode+ Sets the billing mode, with the current supported
    #   options being "PROVISIONED" and "PAY_PER_REQUEST". If using
    #   "PAY_PER_REQUEST" you must not set provisioned throughput values,
    #   and if using "PROVISIONED" you must set provisioned throughput
    #   values. Default assumption is "PROVISIONED".
    #
    # @example Defining a migration with a GSI.
    #   class Forum
    #   include Aws::Record
    #   string_attr     :forum_uuid, hash_key: true
    #   integer_attr    :post_id,    range_key: true
    #   string_attr     :post_title
    #   string_attr     :post_body
    #   string_attr     :author_username
    #   datetime_attr   :created_date
    #   datetime_attr   :updated_date
    #   string_set_attr :tags
    #   map_attr        :metadata, default_value: {}
    #
    #   global_secondary_index(
    #   :title,
    #   hash_key:  :forum_uuid,
    #   range_key: :post_title,
    #   projection_type: "ALL"
    #   )
    #   end
    #
    #   table_config = Aws::Record::TableConfig.define do |t|
    #   t.model_class Forum
    #   t.read_capacity_units 10
    #   t.write_capacity_units 5
    #
    #   t.global_secondary_index(:title) do |i|
    #   i.read_capacity_units 5
    #   i.write_capacity_units 5
    #   end
    #   end
    #
    # source://aws-record//lib/aws-record/record/table_config.rb#146
    def define(&block); end
  end
end

# @api private
#
# source://aws-record//lib/aws-record/record/table_config.rb#630
class Aws::Record::TableConfig::GlobalSecondaryIndex
  # @api private
  # @return [GlobalSecondaryIndex] a new instance of GlobalSecondaryIndex
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#633
  def initialize; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#631
  def provisioned_throughput; end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#637
  def read_capacity_units(units); end

  # @api private
  #
  # source://aws-record//lib/aws-record/record/table_config.rb#641
  def write_capacity_units(units); end
end

# source://aws-record//lib/aws-record/record/table_migration.rb#5
class Aws::Record::TableMigration
  # @option opts
  # @param model [Aws::Record] a model class that includes {Aws::Record}.
  # @param opts [Hash]
  # @return [TableMigration] a new instance of TableMigration
  #
  # source://aws-record//lib/aws-record/record/table_migration.rb#19
  def initialize(model, opts = T.unsafe(nil)); end

  # @return [Aws::DynamoDB::Client] the
  #   {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html Aws::DynamoDB::Client}
  #   class used by this table migration instance.
  #
  # source://aws-record//lib/aws-record/record/table_migration.rb#10
  def client; end

  # Sets the attribute client
  #
  # @param value the value to set the attribute client to.
  #
  # source://aws-record//lib/aws-record/record/table_migration.rb#10
  def client=(_arg0); end

  # This method calls
  # {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#create_table-instance_method
  # Aws::DynamoDB::Client#create_table}, populating the attribute definitions and
  # key schema based on your model class, as well as passing through other
  # parameters as provided by you.
  #
  # @example Creating a table with a global secondary index named +:gsi+
  #   migration.create!(
  #   provisioned_throughput: {
  #   read_capacity_units: 5,
  #   write_capacity_units: 2
  #   },
  #   global_secondary_index_throughput: {
  #   gsi: {
  #   read_capacity_units: 3,
  #   write_capacity_units: 1
  #   }
  #   }
  #   )
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] options to pass on to the client call to
  #   +#create_table+. See the documentation above in the AWS SDK for Ruby
  #   V2.
  #
  # source://aws-record//lib/aws-record/record/table_migration.rb#63
  def create!(opts); end

  # This method calls
  # {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#delete_table-instance_method
  # Aws::DynamoDB::Client#delete_table} using the table name of your model.
  #
  # @raise [Aws::Record::Errors::TableDoesNotExist] if the table did not
  #   exist in Amazon DynamoDB at the time of calling.
  #
  # source://aws-record//lib/aws-record/record/table_migration.rb#117
  def delete!; end

  # This method calls
  # {http://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#update_table-instance_method
  # Aws::DynamoDB::Client#update_table} using the parameters that you provide.
  #
  # @param opts [Hash] options to pass on to the client call to
  #   +#update_table+. See the documentation above in the AWS SDK for Ruby
  #   V2.
  # @raise [Aws::Record::Errors::TableDoesNotExist] if the table does not
  #   currently exist in Amazon DynamoDB.
  #
  # source://aws-record//lib/aws-record/record/table_migration.rb#102
  def update!(opts); end

  # This method waits on the table specified in the model to exist and be
  # marked as ACTIVE in Amazon DynamoDB. Note that this method can run for
  # several minutes if the table does not exist, and is not created within
  # the wait period.
  #
  # source://aws-record//lib/aws-record/record/table_migration.rb#127
  def wait_until_available; end

  private

  # source://aws-record//lib/aws-record/record/table_migration.rb#192
  def _add_throughput_to_gsis(global_secondary_indexes, gsi_throughput); end

  # source://aws-record//lib/aws-record/record/table_migration.rb#170
  def _append_to_attribute_definitions(secondary_indexes, create_opts); end

  # source://aws-record//lib/aws-record/record/table_migration.rb#133
  def _assert_model_valid(model); end

  # @raise [Errors::InvalidModel]
  #
  # source://aws-record//lib/aws-record/record/table_migration.rb#138
  def _assert_required_include(model); end

  # source://aws-record//lib/aws-record/record/table_migration.rb#161
  def _attribute_definitions; end

  # source://aws-record//lib/aws-record/record/table_migration.rb#209
  def _key_schema; end

  # source://aws-record//lib/aws-record/record/table_migration.rb#218
  def _keys; end

  # source://aws-record//lib/aws-record/record/table_migration.rb#144
  def _validate_billing(opts); end
end

# source://aws-record//lib/aws-record/record/transactions.rb#7
module Aws::Record::Transactions
  extend ::Aws::Record::ClientConfiguration

  class << self
    # Provides support for the
    # {https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#transact_get_items-instance_method
    # Aws::DynamoDB::Client#transact_get_item} for aws-record models.
    #
    # This method runs a transactional find across multiple DynamoDB
    # items, including transactions which get items across multiple actual
    # or virtual tables. This call can contain up to 100 item keys.
    #
    # DynamoDB will reject the request if any of the following is true:
    # * A conflicting operation is in the process of updating an item to be read.
    # * There is insufficient provisioned capacity for the transaction to be completed.
    # * There is a user error, such as an invalid data format.
    # * The aggregate size of the items in the transaction cannot exceed 4 MB.
    #
    # @example Usage Example
    #   class TableOne
    #   include Aws::Record
    #   string_attr :uuid, hash_key: true
    #   end
    #
    #   class TableTwo
    #   include Aws::Record
    #   string_attr :hk, hash_key: true
    #   string_attr :rk, range_key: true
    #   end
    #
    #   results = Aws::Record::Transactions.transact_find(
    #   transact_items: [
    #   TableOne.tfind_opts(key: { uuid: "uuid1234" }),
    #   TableTwo.tfind_opts(key: { hk: "hk1", rk: "rk1"}),
    #   TableTwo.tfind_opts(key: { hk: "hk2", rk: "rk2"})
    #   ]
    #   ) # => results.responses contains nil or marshalled items
    #   results.responses.map { |r| r.class } # [TableOne, TableTwo, TableTwo]
    # @option opts
    # @option opts
    # @param opts [Hash] Options to pass through to
    #   {https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#transact_get_items-instance_method
    #   Aws::DynamoDB::Client#transact_get_items}, with the exception of the
    #   +:transact_items+ array, which uses the {ItemOperations.ItemOperationsClassMethods.tfind_opts #tfind_opts}
    #   operation on your model class to provide extra metadata
    #   used to marshal your items after retrieval.
    # @return [OpenStruct] Structured like the client API response from
    #   +#transact_get_items+, except that the +responses+ member contains
    #   +Aws::Record+ items marshaled into the classes used to call
    #   +#tfind_opts+ in each positional member. See the usage example.
    #
    # source://aws-record//lib/aws-record/record/transactions.rb#60
    def transact_find(opts); end

    # Provides support for the
    # {https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#transact_write_items-instance_method
    # Aws::DynamoDB::Client#transact_write_items} for aws-record models.
    #
    # This method passes in aws-record items into transactional writes,
    # as well as adding the ability to run 'save' commands in a transaction
    # while allowing aws-record to determine if a :put or :update operation
    # is most appropriate. +#transact_write+ supports 5 different transact
    # item modes:
    # - save: Behaves much like the +#save+ operation on the item itself.
    #   If the keys are dirty, and thus it appears to be a new item, will
    #   create a :put operation with a conditional check on the item's
    #   existence. Note that you cannot bring your own conditional
    #   expression in this case. If you wish to force put or add your
    #   own conditional checks, use the :put operation.
    # - put: Does a force put for the given item key and model.
    # - update: Does an upsert for the given item.
    # - delete: Deletes the given item.
    # - check: Takes the result of +#transact_check_expression+,
    #   performing the specified check as a part of the transaction.
    #   See {ItemOperations.ItemOperationsClassMethods.transact_check_expression #transact_check_expression}
    #   for more information.
    #
    # This call contain up to 100 action requests.
    #
    # DynamoDB will reject the request if any of the following is true:
    # * A condition in one of the condition expressions is not met.
    # * An ongoing operation is in the process of updating the same item.
    # * There is insufficient provisioned capacity for the transaction to
    #   be completed.
    # * An item size becomes too large (bigger than 400 KB), a local secondary
    #   index (LSI) becomes too large, or a similar validation error occurs
    #   because of changes made by the transaction.
    # * The aggregate size of the items in the transaction exceeds 4 MB.
    # * There is a user error, such as an invalid data format.
    #
    # @example Usage Example
    #   class TableOne
    #   include Aws::Record
    #   string_attr :uuid, hash_key: true
    #   string_attr :body
    #   end
    #
    #   class TableTwo
    #   include Aws::Record
    #   string_attr :hk, hash_key: true
    #   string_attr :rk, range_key: true
    #   string_attr :body
    #   end
    #
    #   check_exp = TableOne.transact_check_expression(
    #   key: { uuid: "foo" },
    #   condition_expression: "size(#T) <= :v",
    #   expression_attribute_names: {
    #   "#T" => "body"
    #   },
    #   expression_attribute_values: {
    #   ":v" => 1024
    #   }
    #   )
    #   new_item = TableTwo.new(hk: "hk1", rk: "rk1", body: "Hello!")
    #   update_item_1 = TableOne.find(uuid: "bar")
    #   update_item_1.body = "Updated the body!"
    #   put_item = TableOne.new(uuid: "foobar", body: "Content!")
    #   update_item_2 = TableTwo.find(hk: "hk2", rk: "rk2")
    #   update_item_2.body = "Update!"
    #   delete_item = TableOne.find(uuid: "to_be_deleted")
    #
    #   Aws::Record::Transactions.transact_write(
    #   transact_items: [
    #   { check: check_exp },
    #   { save: new_item },
    #   { save: update_item_1 },
    #   {
    #   put: put_item,
    #   condition_expression: "attribute_not_exists(#H)",
    #   expression_attribute_names: { "#H" => "uuid" },
    #   return_values_on_condition_check_failure: "ALL_OLD"
    #   },
    #   { update: update_item_2 },
    #   { delete: delete_item }
    #   ]
    #   )
    # @option opts
    # @option opts
    # @param opts [Hash] Options to pass through to
    #   {https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/DynamoDB/Client.html#transact_write_items-instance_method
    #   Aws::DynamoDB::Client#transact_write_items} with the exception of
    #   :transact_items array, which is transformed to use your item to populate
    #   the :key, :table_name, :item, and/or :update_expression parameters
    #   as appropriate. See the usage example for a comprehensive set of combinations.
    #
    # source://aws-record//lib/aws-record/record/transactions.rb#201
    def transact_write(opts); end

    private

    # source://aws-record//lib/aws-record/record/transactions.rb#303
    def _transform_check_record(check_record, opts); end

    # source://aws-record//lib/aws-record/record/transactions.rb#279
    def _transform_delete_record(delete_record, opts); end

    # source://aws-record//lib/aws-record/record/transactions.rb#272
    def _transform_put_record(put_record, opts); end

    # source://aws-record//lib/aws-record/record/transactions.rb#248
    def _transform_save_record(save_record, opts); end

    # source://aws-record//lib/aws-record/record/transactions.rb#222
    def _transform_transact_write_items(transact_items, dirty_items, delete_items); end

    # source://aws-record//lib/aws-record/record/transactions.rb#286
    def _transform_update_record(update_record, opts); end
  end
end

# source://aws-record//lib/aws-record/record/version.rb#5
Aws::Record::VERSION = T.let(T.unsafe(nil), String)
