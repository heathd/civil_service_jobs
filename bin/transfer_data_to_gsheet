#!/usr/bin/env ruby

#typed: true

$LOAD_PATH << File.dirname(__FILE__) + "/../config/"
require 'init'

require 'logger'
require 'googleauth'
require 'google/apis/sheets_v4'
require 'date'
require 'time'
require 'tzinfo'
require "reverse_markdown"

class GoogleSheet
  attr_reader :authorizer, :spreadsheet_id, :logger, :table_range, :rows

  def initialize(spreadsheet_id:, table_range:, logger: Logger.new(nil))
    authorize!
    @spreadsheet_id = spreadsheet_id
    @table_range = table_range
    @logger = logger
    @rows = []
  end

  def authorize!
    if %W{GOOGLE_CLIENT_ID GOOGLE_CLIENT_EMAIL GOOGLE_PRIVATE_KEY}.all? {|env_var| ENV.has_key?(env_var) }
      # ok can use these env vars
      @authorizer = Google::Auth::ServiceAccountCredentials.make_creds(
        scope: 'https://www.googleapis.com/auth/spreadsheets'
      )
    elsif ENV.has_key?("GOOGLE_CLOUD_CREDS")
      @authorizer = Google::Auth::ServiceAccountCredentials.make_creds(
        json_key_io: StringIO.new(ENV.fetch("GOOGLE_CLOUD_CREDS")),
        scope: 'https://www.googleapis.com/auth/spreadsheets'
      )
    else
      raise "Must pass credentials in ENV, either:
        - GOOGLE_CLOUD_CREDS containing the full JSON credentials structure downloaded from google cloud
        - or GOOGLE_CLIENT_ID GOOGLE_CLIENT_EMAIL GOOGLE_PRIVATE_KEY containing these credentials"
    end
  end

  def sheets_service
    @sheets_service ||= begin
      service = Google::Apis::SheetsV4::SheetsService.new
      service.authorization = authorizer
      service
    end
  end

  def flush!
    value_range_object = Google::Apis::SheetsV4::ValueRange.new(
      range: table_range,
      major_dimension: 'ROWS',
      values: rows
    )

    sent = T.let(false, T::Boolean)
    tries = 0
    response = T.let(nil, T.nilable(Google::Apis::SheetsV4::AppendValuesResponse))

    logger.info "Appending #{rows.size} rows to sheet"
    while !sent
      begin
        tries += 1

        response = sheets_service.append_spreadsheet_value(
          spreadsheet_id,
          table_range,
          value_range_object,
          value_input_option: 'RAW'
        )
        sent = true
        logger.info "Successfully appended #{rows.size} rows to sheet"
        @rows = []
        response
      rescue Google::Apis::RateLimitError => e
        if tries < 20
          sleep_time = tries^2 / 2
          logger.info "Request was rate limited, sleeping for #{sleep_time} before attempt number #{tries}"
          sleep(sleep_time)
        else
          raise
        end
      end
    end
  end

  def approx_batch_size_in_bytes
    rows.map do |row|
      row.map {|v| v.to_s.size}.sum
    end.sum
  end

  def append_row(row)
    rows << row
    if (approx_batch_size_in_bytes > 1_500_000)
      flush!
    end
  end

  def refcodes_of_jobs_already_in_sheet
    @refcodes_of_jobs_already_in_sheet ||= begin
      response = sheets_service.get_spreadsheet_values(spreadsheet_id, 'Sheet1!C:C')
      response.values[1..-1].reject(&:empty?).map {|row| row.first}
    end
  end
end

extend T::Sig

sig{params(datetime: TZInfo::DateTimeWithOffset).returns(Numeric)}
def generate_google_datetime(datetime)
	#	The integer part represents the number of days since December 30, 1899. For example, 1 represents December 31, 1899, 2 represents January 1, 1900, and so on.
	#	The fractional part represents the fraction of the day. For example, 0.5 represents 12:00 PM (noon), 0.75 represents 6:00 PM, and so on.
  reference_date = Date.new(1899,12,30)
  integer_part = datetime.to_date - reference_date

  fractional_part = datetime.hour/24r + datetime.minute/(24*60r) + datetime.second/(24*60*60r)

  (integer_part + fractional_part).to_f
end

sig {params(html: T.nilable(String)).returns(String)}
def html_to_markdown(html)
  ReverseMarkdown.convert(html || "")
end

sig {params(
  job: CivilServiceJobsScraper::DynamoDbResultStore::JobMainRecord,
  body: T.nilable(CivilServiceJobsScraper::DynamoDbResultStore::JobBodyRecord)
  ).returns(T::Array[String])}
def spreadsheet_row_for_job(job, body)
  tz = TZInfo::Timezone.get("Europe/London")

  [
    generate_google_datetime(tz.to_local(job.created_at)),
    tz.to_local(job.created_at).strftime('%Z'),
    job.refcode,
    job.title,
    job.department,
    job.location,
    job.salary,
    job.closingdate,
    job.grade,
    job.stage,
    job.reference_number,
    job.job_grade,
    job.number_of_jobs_available,
    job.job_grade_0,
    job.job_grade_1,
    job.contract_type,
    job.business_area,
    job.type_of_role,
    job.working_pattern,
    job.length_of_employment,
    html_to_markdown(body && body.body)
  ]
end

LOGGER = Logger.new($stdout)
$stdout.sync = true
sheet = GoogleSheet.new(spreadsheet_id: '1qXl4o0aKL3kAbDpoNJD8XeAFjMXIWjCXTWK-PWDL-DM',
                        table_range: 'Sheet1!A1', logger: LOGGER)

store = CivilServiceJobsScraper::DynamoDbResultStore.new
store.each.with_index do |job, i|
  if sheet.refcodes_of_jobs_already_in_sheet.include?(job.refcode)
    LOGGER.info "#{i}: #{job.refcode} #{job.title} -- already in sheet"
  else
    LOGGER.info "#{i}: #{job.refcode} #{job.title} (#{job.created_at}) - loading"
    row = spreadsheet_row_for_job(job, job.body_record)
    sheet.append_row(row)
  end
end
sheet.flush!
